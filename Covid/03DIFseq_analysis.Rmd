---
title: "Posterior inference for simulation_v67"
author: "Fangda, Song"
date: "2023-02-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r ver}
library(mclust)
library(bigmemory)
library(ggplot2)
library(Seurat)
library(viridis) # coloring for the heatmap of batch effects
library(patchwork)
library(xtable)

library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization

# Heatmap
library(RColorBrewer)
library(pheatmap)

proj <- "covid_sc"
ver <- 53

if(!dir.exists("Images")){
  dir.create("Images")
}
```
# Explore the posterior inference

## select the optimal number of cell types by the BIC plot
```{r BIC}
load(paste0("Model_selection_post_v",ver,".RData"))
K_sel <- 11:20
BIC_table <- summary_results[[1]][,1:3]
BIC_values <- apply(BIC_table,1,min,na.rm=TRUE)

ind_min <- which.min(BIC_values)
K_opt <- K_sel[ind_min]
r_opt <- which.min(BIC_table[ind_min, ])


dir_inference <- paste0("K",K_opt,"_r",r_opt,"/Inference_K",K_opt,"/")

if(length(K_sel) == length(BIC_values)){
  jpeg(paste0("Images/BIC_plot_simulation_v",ver,".jpg"),width = 540, height = 1080, quality = 100)
  par(mar = c(5.1,6.1,4.1,2.1)) 
  plot(K_sel,BIC_values,xlab= "K",ylab = "BIC",type="n",cex.axis=2,cex.lab=3)
  points(K_sel,BIC_values,type="b",pch=19,cex=3)
  dev.off()
}

```

### Draw BIC plot
```{r}

load(paste0("Model_selection_post_v53.RData"))
BIC_table <- summary_results[[1]][1:5,1:4]
BIC_values <- apply(BIC_table,1,min,na.rm=TRUE)

load(paste0("Model_selection_post_v54.RData"))
BIC_table <- summary_results[[1]][1:3,1:4]
BIC_values <- c(apply(BIC_table,1,min,na.rm=TRUE), BIC_values)

K_sel <- 8:15

pdf(paste0("Images/BIC_plot_",proj,"_v",ver,".pdf"),width = 8, height = 8)
par(mar = c(5.1,6.1,4.1,2.1)) 
plot(K_sel,BIC_values,xlab= "K",ylab = "BIC",type="n",cex.axis=2,cex.lab=3)
points(K_sel,BIC_values,type="b",pch=19,cex=3)
dev.off()
```


```{r replication}
ver_dat <- 0
y_obs <- read.table(paste0("../RawCountData/count_data_",proj,"_v",ver_dat,".txt"))
y_obs <- as.matrix(y_obs)

adt_count <- read.table(paste0("../RawCountData/adt_data_",proj,"_v",ver_dat,".txt"))
adt_temp <- as.matrix(adt_count[,-1])
rownames(adt_temp) <- adt_count[,1]
adt_count <- adt_temp

# Load dimension
dim <- read.table(paste0("../RawCountData/dim_",proj,"_v",ver_dat,".txt"))
dim <- unlist(dim)
N <- dim[1]
S <- dim[2]
G <- dim[3]
B <- dim[4]
Num_Treatment <- dim[5]
P <- dim[6]
BT_pair <- matrix(dim[6 + 1:(3*P)], byrow = TRUE, nrow = P)
colnames(BT_pair) <- c("Batch", "Treatment", "n_bt")

# Load metadata
metadata <- read.table(paste0("../RawCountData/metadata_",proj,"_v",ver_dat,".txt"), header = TRUE)
# colnames(metadata) <- c("Batch", "Treatment", "CellType")
  
# Load the gene list
gene_list <- unlist(read.table(paste0("../RawCountData/gene_list_",proj,"_v",ver_dat,".txt"),stringsAsFactors = F))

# Add row and column names for the raw count data matrix
rownames(y_obs) <- gene_list
colnames(y_obs) <- metadata$Sample

# indices of cells
btp_ind <- read.table(paste0("../RawCountData/tbinfor_",proj,"_v",ver_dat,".txt"))
```
Finally, we select the `r r_opt`th replicate of K = `r K_opt`.

<!-- ## Warm-up cluster -->
<!-- We cluster cells in each batch -->

<!-- ```{r, eval = FALSE} -->
<!-- library(edgeR) -->
<!-- library(cluster) -->

<!-- dim(y_obs)  -->
<!-- rownames(y_obs) <- gene_list -->
<!-- colnames(y_obs) <- metadata$Sample -->


<!-- # normalization -->
<!-- y_norm <- cpm(y_obs, log = TRUE) -->
<!-- obs_df <- data.frame(t(y_norm)) -->

<!-- # scaling -->
<!-- obs_df <- scale(obs_df) -->

<!-- # clustering on the first batch -->
<!-- batch_df <- obs_df[btp_ind[,1] == 1, ] -->

<!-- for(K_initial in 3:8) { -->
<!--   cluster_batch <- pam(batch_df, k = K_initial) -->

<!--   # medoids -->
<!--   Medoids_batch <- cluster_batch$medoids -->
<!--   w_inital <- rep(NA, N) -->
<!--   for (i in 1:N) { -->
<!--     # L1_dist <- colSums(abs(t(Medoids_batch)- obs_df[i,])) -->
<!--     Man_dist <- -->
<!--       get_dist(rbind(obs_df[i, ], Medoids_batch), method = "pearson") -->
<!--     w_inital[i] <- which.min(Man_dist[1:K_initial]) -->
<!--   } -->

<!--   write.table( -->
<!--     w_inital, -->
<!--     file = paste0("RawCountData/w_initial_K", K_initial, ".txt"), -->
<!--     row.names = FALSE, -->
<!--     col.names = FALSE -->
<!--   ) -->
<!-- } -->

<!-- ``` -->

## Inspect the running time of each step in the MCESM algorithm
Here, we record the running time of the steps in the stochastic EM algorithm. Maybe we can draw a pie chart to show the proportions of each part.

```{r time}
time_con <- read.table(file = paste0(dir_inference,"time_consumption.txt"),header = FALSE)
colnames(time_con) <- c("E step for spike-and-slab priors","M step for pi",
                        "MCE step","SM step for gamma","SM step for abnep",
                        "M step for delta","M step for p and tau",
                        "Calculate the likelihood")
time_per_iter <- apply(time_con,2 ,mean)
time_percentage <- round(time_per_iter/sum(time_per_iter) * 100, digits = 2)
time_percentage

iter_infor <- unlist(read.table(paste0(dir_inference,"iter_infor.txt")))

iter_num <- nrow(time_con)
plot(c(1,iter_num), c(0,150),type = "n", xlab = "No. of Iterations", ylab = "Time (s)")
lines(1:iter_num, time_con[,2], col = 2)
lines(1:iter_num, time_con[,3], col = 3)
# lines(1:iter_num, time_con[,6], col = 5)
abline(v = iter_infor[3], lty = 2, col = 2)
abline(v = sum(iter_infor[3:4]), lty = 2, col = 2)
abline(v = sum(iter_infor[3:5]), lty = 2, col = 2)
```

## Inspect the convergence of parameter estimation by traceplots
Here, we draw the traceplots of different parameters to check their convergence.
```{r convergence, eval = FALSE}
## Take a look at the convergence
Traceplot <- function(par, subset = NULL, range = NULL, 
                      ...){
  N_iter <- nrow(par)
  Dim <- ncol(par)
  if(!is.null(subset)){
    par <- par[,subset]
  }
  
  # determine the range of the plot
  if(is.null(range)){
    for(i in 1:N_iter){
      range_i <- range(par[i,])
      range <- range(c(range,range_i))
    }
  }
  
  p <- plot(c(1,N_iter), range, type = "n", 
            xlab = "IterNum", ...)
  for(g in 1:Dim){
    p <- lines(par[,g],col = g)
  }
  return(p)
}

iter_dir <- paste0("K",K_opt,"_r",r_opt,"/MCESM_iter_K",K_opt,"/")

mini_batch <- 10000
sub_trace <- paste("Traceplot of minibatch size equal to",mini_batch) 

alpha_post <- read.big.matrix(paste0(iter_dir,"alpha_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_alpha_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(alpha_post, ylab = expression(alpha[g]), 
          main = sub_trace)
dev.off()

beta_post <- read.big.matrix(paste0(iter_dir,"beta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_beta_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(beta_post, ylab = expression(beta[gk]), 
          main = sub_trace)
dev.off()

eta_post <- read.big.matrix(paste0(iter_dir,"eta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_eta_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(eta_post, ylab = expression(eta[tgk]), 
          main = sub_trace)
dev.off()

nu_post <- read.big.matrix(paste0(iter_dir,"nu_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_nu_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(nu_post, ylab = expression(nu[bg]),
          main = sub_trace)
dev.off()

delta_post <- read.big.matrix(paste0(iter_dir,"delta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_delta_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(delta_post, ylab = expression(delta[btgi]), 
          main = sub_trace)
dev.off()

phi_post <- read.big.matrix(paste0(iter_dir,"phi_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_phi_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(phi_post, ylab = expression(phi[bg]), 
          main = sub_trace)
dev.off()

gamma_post <- read.big.matrix(paste0(iter_dir,"gamma_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_gamma_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
Traceplot(gamma_post, ylab = expression(gamma[b]), 
          main = sub_trace)
dev.off()

# Traceplot of ARI
w_post <- read.big.matrix(paste0(iter_dir,"w_iter.txt"), type = "double", sep = " ")
record_num <- nrow(w_post)
ARI_post <- rep(NA, record_num)
for(i in 1:record_num){
  ARI_post[i] <- adjustedRandIndex(w_post[i,], metadata$Seurat_Level2)
}
jpeg(filename = paste0("Images/Traceplot_ARI_",proj,"_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 800, height = 600)
plot(1:record_num * 5, ARI_post, type = "l", xlab = "No. of Iterations", ylab = "ARI")
abline(v = iter_infor[3], lty = 2, col = 2)
abline(v = sum(iter_infor[3:4]), lty = 2, col = 2)
abline(v = sum(iter_infor[3:5]), lty = 2, col = 2)

xaxis = c(iter_infor[3]/2, iter_infor[3] + iter_infor[4]/2, sum(iter_infor[3:4]) + iter_infor[5]/2, sum(iter_infor[3:5]) + iter_infor[6]/2)
text(xaxis, 0.5, labels = paste("Stage",1:4))
dev.off()
```

<!-- Debug for the outliers of beta and eta  -->
<!-- ```{R, eval = FASLE} -->
<!-- arrayInd(which(beta_est > 30),dim(beta_est)) -->

<!-- # Debug for why there is a gene with gene expression levels equal to 27.805 -->
<!-- g <- 2280 -->
<!-- y_g <- y_obs[g, ] -->

<!-- logmu_est_g <- matrix(alpha_est[g] + beta_est[g,] + eta_est[g,], nrow = K_opt) -->

<!-- # Draw a boxplot for this gene across 10 iterations -->
<!-- # Or I should not fix tau1sq in stage 2? -->
<!-- # What's the gradient for beta_gk and eta_tgk, when k = 13? -->
<!-- colnames(btp_ind) <- c("Batch", "Treatment", "Pair", "Sample") -->
<!-- btp_ind$gene2282 <- y_g -->
<!-- btp_ind$cluster <- w_est -->

<!-- ggplot(btp_ind, aes(x = factor(w_est), y = gene2282, col = factor(Batch), fill = factor(Treatment))) + -->
<!--   geom_boxplot() -->

<!-- # Why eta_tgk can go to 20 for t = 1 and t = 2? -->
<!-- x_imputed <- read.table(paste0(dir_inference,"imputed_count.txt")) -->
<!-- x_g <- x_imputed[g,] -->

<!-- btp_ind$gene2282imputed <- unlist(x_g) -->

<!-- ggplot(btp_ind, aes(x = factor(w_est), y = gene2282imputed, col = factor(Batch), fill = factor(Treatment))) + -->
<!--   geom_boxplot() -->

<!-- # Update beta_gk and eta_tgk -->
<!-- k <- 1 -->
<!-- logmu_cur <- matrix(NA, N, K_opt) -->

<!-- for(i in 1:N){ -->
<!--   b <- btp_ind[i,1] -->
<!--   t <- btp_ind[i,2] -->

<!--   logmu_cur[i,] <- alpha_est[g] + beta_est[g,] + eta_est[g,(t-1) * K_opt +1:K_opt] + nu_est[g,b] + delta_est[i] -->
<!-- } -->
<!-- phi_cur <- phi_est[g,] -->

<!-- fir_der <- rep(0, K_opt) -->
<!-- sec_der <- rep(0, K_opt) -->

<!-- for(i in 1:N){   -->

<!--   k <- w_est[i] -->
<!--   # loglikelihood -->
<!--   fir_der[k] <- fir_der[k] + y_g[i] - (y_g[i] + phi_cur[b]) * exp(logmu_cur[i,k]) / (exp(logmu_cur[i,k]) + phi_cur[b]) -->
<!--   sec_der[k] <- sec_der[k] - (y_g[i] + phi_cur[b]) * exp(logmu_cur[i,k]) * phi_cur[b] / (exp(logmu_cur[i,k]) + phi_cur[b])^2 -->
<!-- } -->

<!-- fir_der/sec_der -->

<!-- # The gradient of eta -->
<!-- fir_der_eta <- matrix(0, Num_Treatment, K_opt) -->
<!-- sec_der_eta <- matrix(0, Num_Treatment, K_opt) -->

<!-- for(i in 1:N){ -->
<!--   k <- w_est[i] -->
<!--   t <- btp_ind[i,2] -->

<!--   fir_der_eta[t,k] <- fir_der_eta[t,k] + y_g[i] - (y_g[i] + phi_cur[b]) * exp(logmu_cur[i,k]) / (exp(logmu_cur[i,k]) + phi_cur[b]) -->
<!--   sec_der_eta[t,k] <- sec_der_eta[t,k] - (y_g[i] + phi_cur[b]) * exp(logmu_cur[i,k]) * phi_cur[b] / (exp(logmu_cur[i,k]) + phi_cur[b])^2 -->
<!-- } -->

<!-- # adjust for eta_0 -->

<!-- ``` -->

## Load the estimated parameter values
First, we load the posterior estimators of parameters:
```{r est}
# load cell type labels
w_est <- read.table(paste0(dir_inference,"w_est.txt"))
w_est <- unlist(w_est)
# table(w_est, metadata$CellType)

# load alpha_est
alpha_est <- read.table(paste0(dir_inference,"alpha_est.txt"))
alpha_est <- unlist(alpha_est)

# load beta_est
beta_est <- read.table(paste0(dir_inference,"beta_est.txt"))
beta_est <- matrix(unlist(beta_est),G,K_opt)
logmu_est<-beta_est+alpha_est

# load eta_est
eta_est <- read.table(paste0(dir_inference,"eta_est.txt"))
eta_est <- matrix(unlist(eta_est),G,K_opt * Num_Treatment)

# load nu_est #
nu_est <- read.table(paste0(dir_inference,"nu_est.txt"))
nu_est <- matrix(unlist(nu_est),G,B)

# load delta_est
delta_est <- read.table(paste0(dir_inference,"delta_est.txt"))
delta_est <- unlist(delta_est)

# load phi_est
phi_est <- read.table(paste0(dir_inference,"phi_est.txt"))
phi_est <- matrix(unlist(phi_est),G,B)

# load pi_est
pi_est <- read.table(paste0(dir_inference,"pi_est.txt"))
pi_est <- matrix(unlist(pi_est),S,K_opt)

# load p and tau0
ptau1 <- unlist(read.table(paste0(dir_inference,"ptau1_est.txt")))
tau0 <- 0.1
tau1_est <- ptau1[1]
pbeta_est <- ptau1[2]
peta_est <- ptau1[3]

# Load the imputed read counts
x_imputed <- read.table(paste0(dir_inference,"imputed_count.txt"))
colnames(x_imputed) <- paste0(metadata$Sample_id, metadata$Barcode)
rownames(x_imputed) <- gene_list
```

# Cell type annotation

We adjust for the order of cell types such that the contingency table of the estimated cell type labels and the Seurat labels concentrates in the diagonal line.
```{r cluster}
# celltype_name <- c("Alpha", "Beta", "Delta", "Gamma", "Acinar", "Ductal", "other")
# metadata$CellType <- factor(metadata$CellType, levels = celltype_name)
table_celltype <- table(metadata$Seurat_Level2, w_est)
Seurat_switch <- c(2:4, 29,7:15, 25,28, 16:17, 5:6,  30, 22)
est_switch <- c(12, 9, 3, 11, 4, 5, 6, 8, 2, 10, 1, 7)
table_celltype <- table_celltype[Seurat_switch,est_switch]
table_celltype

table(metadata$Seurat_Level1, w_est)[,est_switch]
```
We annotate our clusters by Seurat labels. 
```{r}
# v44
# celltype_name <-  c("Bcells_1", "Bcells_2", "Plasmablast", "CD4Tcells_1", "CD4Tcells_2",
#                     "CD8cells", "NK_1", "NK_2", 
#                     "pDC", "cDC_1", "cDC_2", "CD14Mono_1", "CD14Mono_2", "CD14Mono_3",
#                     "CD16Mono", "Platelet")

# v46
# celltype_name <-  c("Bcells_1", "Bcells_2", "Plasmablast_1", "Plasmablast_2", 
#                     "CD4Tcells", "CD8Tcells", "NK_1", "NK_2", 
#                     "pDC", "cDC", "CD14Mono", "Mono", "CD16Mono",
#                     "Platelet_1", "Platelet_2")

# # v47
# celltype_name <-  c("Bcells_1", "Bcells_2", "Plasmablast&CD8Tcells", "CD4Tcells_1", "CD4Tcells_2", 
#                     "NK_1", "NK_2", "pDC", "cDC", 
#                     "CD14Mono_1", "CD14Mono_2", "CD16Mono", "Platelet")

# v53 K12_r3
celltype_name <-  c("B cells", "Plasma cells", "CD4+ T cells 1", 
                    "CD4+ T cells 2", "CD8+ T cells", 
                    "NK 1", "NK 2", "pDC", "cDC", 
                    "CD14+ Monocyte",  "CD16+ Monocyte", "Platelet")

pi_ordered <- pi_est[,est_switch]
colnames(pi_ordered) <- celltype_name
rownames(pi_ordered) <- metadata$Severity[!duplicated(metadata$Sample_id)]
```

## Draw Heatmap of ADT levels by pheatmap

```{r}
dim(adt_count)
num_adt <- nrow(adt_count)

adt_celltype <- matrix(NA, num_adt, K_opt)

for(k in 1:K_opt){
  adt_celltype[,k] <- apply(log1p(adt_count[,w_est == est_switch[k]]), 1, mean)
}
range(adt_celltype)

colnames(adt_celltype) <- colnames(pi_ordered)
rownames(adt_celltype) <- rownames(adt_count)

# break_mu <- seq(0,4.5, length.out = 8)
# jpeg(paste0("Images/heatmap_LogAvgAdt_Celltype_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 720, height = 1080, quality = 100)
# heat_logmu <- heatmap_effects(adt_celltype, color_by_celltype, break_effects = break_mu)#, 
#                               #labRow = rownames(adt_celltype), labCol = colnames(pi_ordered))
# dev.off()


pdf(paste0("Images/heatmap_LogAvgAdt_Celltype_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 8)
pheatmap(adt_celltype, 
         cluster_cols = FALSE,
         cluster_rows = FALSE,
          scale = "none") 
dev.off()

pdf(paste0("Images/heatmap_scaled_LogAvgAdt_Celltype_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 8)
pheatmap(adt_celltype, 
         cluster_cols = FALSE,
         cluster_rows = FALSE,
          scale = "row") 
dev.off()

```

## Draw cell type proprotions of each sample
To show the cell type proportion changes in each individual, we draw the individual-specific cell type proportions $\pi_{sk}$ in a bar plot.

```{r}

sample_id_ordered <- c("259","279","280","258","265",
                         "nCOV1EUHM","nCOV7EUHM","nCOV0029EUHM",
                         "nCOV3EUHM", "nCOV6EUHM","nCOV021EUHM","nCOV024EUHM")

pi.ordered.df <- data.frame(
  Sample=factor(rep(unique(metadata$Sample_id),K_opt),
                levels=sample_id_ordered),
  CellType = factor(rep(colnames(pi_ordered), each = S), levels = celltype_name),
  Prop = as.vector(pi_ordered))

color_by_celltype <- rainbow(K_opt)

pdf(file = paste0("Images/CellTypeProportion_",proj,"_v",ver,".pdf"), width = 12, height = 8)
p <- ggplot(data = pi.ordered.df, mapping = aes(x = Sample, fill = CellType, y = Prop)) + 
  geom_col(width = 1, color = "#939393") +
  scale_fill_manual(values=color_by_celltype) +
  labs(x = "Sample", y = "Cell Type Proportion",colour = "Cell Type") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), #change legend title font size
        legend.text = element_text(size=20),
        panel.grid = element_blank(),
        panel.background =element_blank(),
        panel.border = element_blank()) +
  guides(fill=guide_legend(title="Cell Type")) +
  ylab("Cell-type proportions")
p
dev.off()



#########################################
# Draw color annotation bar by pheatmap #
#########################################
# Define the column names and row names
pi_pheat <- t(pi_ordered)[,c(2,3,1,9,8,5,4,10,6,7,11,12)]
colnames(pi_pheat) <- sample_id_ordered

sample_id <- sample_id_ordered

annotation_samples <- data.frame(
  Treatment = factor(rep(c("Healthy","Moderate","Severe"),c(5,3,4))),
  Batch = factor(paste0("Batch",c(1,1,1,2,2,1,1,2,1,1,2,2))))
rownames(annotation_samples) <- sample_id_ordered

# Specify the color of the annotation bar
color_by_treatment <- c("#ccebc5","#b3cde3","#fbb4ae","#ffffb3")
color_by_batch <- viridis(2)

sample_colors = list(Treatment = c(Healthy = color_by_treatment[1],
                                  Moderate = color_by_treatment[2],
                                  Severe = color_by_treatment[3]),
                     Batch = c(Batch1 = color_by_batch[1],
                               Batch2 = color_by_batch[2]))

pdf(paste0("Images/heatmap_est_pi_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 7, height = 8)
pheatmap(pi_pheat, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =
  "Greys")))(100),
         breaks = seq(0,0.4,length.out = 100),
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         annotation_col = annotation_samples,
         annotation_colors = sample_colors,
         show_colnames = FALSE,
          scale = "none") 
dev.off()
```



# Differential expression

## Intrinsic genes and cell-type-specific DE genes identification 

```{r intrinsic_genes}
.fdrDEindicator <- function(xi, kappa){

  ind_intr <- xi <= kappa
  fdr <- sum(xi[ind_intr])/sum(ind_intr)

  return(fdr)
}

# Calculate the DE posterior probability threshold
.postprob_DE_thr_fun <- function(xi, fdr_threshold=0.05){

  kappa_fdr_matr <- NULL
  kappa_set <- sort(unique(xi))
  
  kappa_ind <- which(kappa_set < 0.5 & kappa_set > fdr_threshold)
  
  for(i in kappa_ind){
    
    kappa <- kappa_set[i]
    fdr <- .fdrDEindicator(xi, kappa=kappa)
    
    if(fdr > fdr_threshold){
      break
    }
  }
  
  kappa <- kappa_set[i-1]
  return(kappa)
}

# Estimate intrinsic gene indicators
.estimate_IG_indicators <- function(xi, postprob_DE_threshold = 0.5){

  EstL <- xi
  EstL[xi >= postprob_DE_threshold] <- 0
  EstL[xi <= postprob_DE_threshold] <- 1
  # message("The output format is a matrix.\n")
  # message(paste0("Each row represents a gene, and each column",
  #               " corresponds to a cell type from 2 to K\n"))
  return(EstL)
}

# Intrinsic gene index
.IG_index <- function(EstIGindicators){
  ind <- which(rowSums(EstIGindicators) > 0)
  message(c(length(ind), " intrinsic genes are found.\n"))
  message("The output format is a vector implying the intrinsic gene",
          " indices.\n")
  return(ind)
}

# Load log(Pr(L = 0)) and log(Pr(J = 0))
PrL_est <- matrix(unlist(read.table(paste0(dir_inference,"PrL_est.txt"))), nrow = G)
PrJ_est <- matrix(unlist(read.table(paste0(dir_inference,"PrJ_est.txt"))), nrow = G)

PrL_est <- exp(PrL_est)
PrJ_est <- exp(PrJ_est)

colnames(PrL_est) <- paste0("K",1:K_opt)
colnames(PrJ_est) <- paste0("T",rep(1:Num_Treatment, each = K_opt),"K",rep(1:K_opt, Num_Treatment))

pval_col <- cbind(PrL_est[,-1], PrJ_est[, K_opt + 1:((Num_Treatment - 1) * K_opt)])

xi_thres <- .postprob_DE_thr_fun(pval_col, 0.01)
DE_est <- .estimate_IG_indicators(pval_col, xi_thres)

D_est <- apply(DE_est[,1:(K_opt-1)], 1, sum) > 0
num_intri <- sum(D_est)

E_est <- apply(DE_est[,K_opt - 1 + 1:((Num_Treatment - 1) * K_opt)], 1, sum) > 0
num_DE <- sum(E_est)

################################################
# consider the expression proportions of genes #
################################################
thres_adj <- 0.3
## intrinsic genes
L_est <- DE_est[,1:(K_opt - 1)]
L_adj <- matrix(0, G, K_opt - 1)

expr_prop <- array(NA, dim = c(G, K_opt, 2))

for(k in 2:K_opt){
  celltype_k <- which(w_est == k)
  for(g in which(L_est[,k-1] == 1)){
    
    yg <- y_obs[g, ]
    
    ygk <- yg[celltype_k]
    ygnk <- yg[-celltype_k]
    
    expr_prop[g,k,1] <- sum(ygk > 0)/length(ygk)
    expr_prop[g,k,2] <- sum(ygnk > 0)/length(ygnk)
    
    if(expr_prop[g,k,1] > thres_adj & expr_prop[g,k,2] > thres_adj){
      L_adj[g, k - 1] <- 1 
    }
  }
  
  jpeg(filename = paste0("Images/BDplot_",proj,"_v",ver,"_Type",k,".jpg"), width = 800, height = 600)
  col_nodes <- rep("black", G)
  col_nodes[L_est[,k-1] == 1] <- "blue"
  col_nodes[L_adj[,k-1] == 1] <- "red"
  plot(alpha_est, beta_est[,k], xlab = "Baseline expression levels alpha", ylab ="cell type effects beta", col = col_nodes)
  dev.off()
}

D_adj <- apply(L_adj, 1, sum) > 0
sum(D_adj)

### output intrinsic genes for KEGG pathway analysis
Intrinsic_genes <- gene_list[D_adj==1]
write.table(Intrinsic_genes, file = paste0("Intrinsic_gene_",proj,"_v",ver,".txt"), row.names = FALSE, col.names = FALSE, quote = FALSE)

# # Select the top intrinsic genes
# rownames(PrL_est) <- gene_list
# PrL_ordered <- PrL_est[, est_switch]
# beta_ordered <- beta_est[, est_switch]
# 
# beta_mean <- apply(beta_ordered, 1, mean)
# names(beta_mean) <- gene_list
# Top2_genes <- names(head(sort(beta_mean),2))
# 
# for(k in 2:K_opt){
#   Top2_genes <- c(Top2_genes, names(head(sort(PrL_ordered[beta_ordered[,k] > 1 & D_adj > 0,k], decreasing = TRUE),2)))
# }
# 
# 
# w_factor <- factor(w_est, levels = est_switch, labels = colnames(pi_ordered))
# Corrected_DIFseq$DIFseq_cluster <- w_factor
# DotPlot(Corrected_DIFseq, features = Top2_genes, cols = c("blue", "red"), dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis()

```

```{r celltype_DE}
J_est <- DE_est[,K_opt - 1 + 1:((Num_Treatment - 1) * K_opt)]
J_adj <- matrix(0, G, (Num_Treatment - 1) * K_opt)

expr_prop_treatment <- array(NA, dim = c(G, Num_Treatment,K_opt, 2))

for(t in 2:Num_Treatment){
  for(k in 1:K_opt){
    celltype_t <- which(w_est == k & btp_ind[,2] == t)
    celltype_other <- which(w_est == k & btp_ind[,2] != t)
    for(g in which(J_est[,k + (t-2) * K_opt] == 1)){
      
      yg <- y_obs[g, ]
      
      ygt <- yg[celltype_t]
      ygnt <- yg[celltype_other]
      
      expr_prop_treatment[g,t,k,1] <- sum(ygt > 0)/length(ygt)
      expr_prop_treatment[g,t,k,2] <- sum(ygnt > 0)/length(ygnt)
      # print(expr_prop_treatment[g,t,k,])
      
      if(expr_prop_treatment[g,t,k,1] > thres_adj & expr_prop_treatment[g,t,k,2] > thres_adj){
        J_adj[g, k + (t-2) * K_opt] <- 1 
      }
    }
    
    # jpeg(filename = paste0("Images/BDplot_",proj,"_v",ver,"_Treatment",t,"_Type",k,".jpg"), width = 800, height = 600)
    # col_nodes <- rep("black", G)
    # col_nodes[J_est[,k + (t-2) * K_opt] == 1] <- "blue"
    # col_nodes[J_adj[,k + (t-2) * K_opt] == 1] <- "red"
    # plot(alpha_est + beta_est[,k], eta_est[,k + (t-1) * K_opt], 
    #      xlab = paste0("Expression levels of cell type ",k), 
    #      ylab =paste0("Effects of treatment ",t), col = col_nodes)
    # dev.off()
  }
}

E_adj <- apply(J_adj, 1, sum) > 0
sum(E_adj)

# Differentially expressed genes across treatments
E_combinded <- J_adj[,1:K_opt] | J_adj[,1:K_opt + K_opt]
E_ordered <- E_combinded[, est_switch]
colnames(E_ordered) <- colnames(pi_ordered)
intri_acorss_treat <- apply(E_ordered,2,sum)


#gene_list <- unlist(gene_list)
for(k in 1:K_opt){
  Intrinsic_genes <- gene_list[E_ordered[,k]==1]
  write.table(Intrinsic_genes, file = paste0("Intrinsic_gene_",proj,"_v",ver,"_",celltype_name[k],".txt"),
              row.names = FALSE, col.names = FALSE, quote = FALSE)
}

# Number of cell-type-specific DE genes between healthy and moderate patients


# Number of cell-type-specific DE genes between healthy and severe patients

```

## Barplot of number of cell-type-specific DE genes
```{r}
J_ordered <- J_adj[,c(est_switch, est_switch+K_opt)]

df_num_DE <- data.frame(CellType = rep(celltype_name,2),
                        Treatment = rep(c("Moderate", "Severe"),each = K_opt),
                        Num_DE_gene = apply(J_ordered, 2, sum))


pdf(file = paste0("Images/DE_gene_number_",proj,"_v",ver,".pdf"), width = 9, height = 6)
p <- ggplot(data = df_num_DE, mapping = aes(x = CellType, fill = Treatment, y = log(Num_DE_gene))) + 
  geom_col(color = "#939393", position=position_dodge()) +
  scale_fill_manual(values=color_by_treatment[2:3]) +
  scale_x_discrete(limits=rev) +
  coord_flip() +
  labs(x = "Cell Type", y = "Log(No. of DE genes)",fill = "Treatment") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        # axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), #change legend title font size
        legend.text = element_text(size=20))
p
dev.off()

```

<!-- ## Calculate the Louis estimators of beta and eta to obtain the top genes for each cell type -->

<!-- ```{r} -->
<!-- # Expected terms -->
<!-- a_est <- alpha_est + apply(beta_est,1,mean) -->
<!-- b_est <- alpha_est + beta_est - a_est -->
<!-- # e_est <-  -->


<!-- Louis_var_b <- matrix(NA, G, K_opt) -->
<!-- Louis_var_beta <- matrix(0, G, K_opt) -->
<!-- # Louis_var_e <- matrix(NA, G, Num_Treatment * K) -->

<!-- for (i in 1:N) { -->
<!--   b <- btp_ind[i, 1] -->
<!--   t <- btp_ind[i, 2] -->
<!--   k <- w_est[i] -->

<!--   latent_counts <- x_imputed[, i] -->
<!--   logmu_temp <- -->
<!--     alpha_est + beta_est[, k] + eta_est[, (t - 1) * K_opt + k] + nu_est[, b] + delta_est[i] -->
<!--   logp_temp <- -log(1 + phi_est[, b] / exp(logmu_temp)) -->

<!--   if (k > 1) { -->
<!--     Louis_var_beta[, k] <- -->
<!--       Louis_var_beta[, k] + phi_est[, b] * (phi_est[, b] + latent_counts) * exp(2 * logp_temp) / exp(logmu_temp) -->
<!--   } -->
<!--   if(i %% 1000 == 0){ -->
<!--     print(paste("Finish compute the approximated Louis estimators for the first",i,"cells.")) -->
<!--   } -->
<!-- } -->

<!-- Louis_var_beta[,-1] <- 1/Louis_var_beta[,-1] -->
<!-- Louis_var_b <- ((K_opt -1)^2 - 1)/K_opt^2 * Louis_var_beta + 1/K_opt^2 * apply(Louis_var_beta, 1, sum) -->

<!-- normal_stat_b <- b_est / sqrt(Louis_var_b)  -->
<!-- pval_b <- pnorm(abs(normal_stat_b), log.p = TRUE, lower.tail = FALSE) -->

<!-- rownames(pval_b) <- gene_list -->

<!-- # Order cell type labels -->
<!-- pval_b_ordered <- pval_b[, est_switch] -->
<!-- colnames(pval_b_ordered) <-  celltype_name -->

<!-- # Top intrinsic genes for different cell type -->
<!-- # B cells 1 -->
<!-- top10_celltype <- names(sort(pval_b_ordered[,1])[1:10]) -->
<!-- g_vec <- which(gene_list %in% top10_celltype) -->

<!-- # Debug for why there is a gene with gene expression levels equal to 27.805 -->
<!-- #  -->
<!-- g <- which(gene_list == "CST7") -->
<!-- y_g <- y_obs[g, ] -->
<!-- logmu_ordered_g <- matrix(alpha_est[g] + beta_est[g,est_switch] + eta_est[g,c(est_switch,est_switch+K_opt,est_switch+2 * K_opt)], nrow = K_opt) -->
<!-- logmu_ordered_g -->

<!-- # Draw a boxplot for this gene across 10 iterations -->
<!-- # Or I should not fix tau1sq in stage 2? -->
<!-- # What's the gradient for beta_gk and eta_tgk, when k = 13? -->
<!-- colnames(btp_ind) <- c("Batch", "Treatment", "Pair", "Sample") -->
<!-- btp_ind$gene_interest <- y_g -->

<!-- names(est_switch) <- 1:K_opt -->
<!-- label_switch <- as.numeric(names(sort(est_switch))) -->
<!-- w_ordered <- label_switch[w_est] -->

<!-- btp_ind$cluster <- w_ordered -->

<!-- ggplot(btp_ind, aes(x = factor(cluster), y = gene_interest, fill = factor(Treatment))) + -->
<!--   geom_boxplot() -->

<!-- save.image("0530DifferentialInference.RData") -->
<!-- ``` -->



## KEGG pathway analysis by DAVID
Output the DAVID table in latex format
```{r, eval = FALSE}
pathway_intri <- read.table(paste0("DAVID_intrinsic_",proj,"_v",ver,".txt"),header = TRUE, sep = "\t")
xtable(pathway_intri[,c(2,5,6)],digits = 3)
```


## Draw dot plot for enriched pathways
```{r KEGG_treat, eval = FALSE}
pathway_cond <- NULL

for(k in 1:K_opt){
  ct <- celltype_name[k]
  pathway_cur <- read.table(paste0("DAVID_",ct,"_",proj,"_v",ver,".txt"),header = TRUE, sep = "\t")
  if(nrow(pathway_cur) > 0){
    pathway_cur <- pathway_cur[,c(2,5,6)]
    pathway_cur <- cbind(ct,pathway_cur)
    
    pathway_cur$Rank <- 1:nrow(pathway_cur)
    
    pathway_cond <- rbind(pathway_cond, pathway_cur)
    
  }
}

# Keep interesting pathways
freq_pathways <- table(pathway_cond$Term)
path_interest <- freq_pathways[freq_pathways > 4]
path_interest <- sort(path_interest, decreasing = TRUE)
path_names <- names(path_interest)

# reorder the interesting list of pathways
path_names[1:2] <- path_names[2:1] # Move COVID-19 pathway to the first
path_names[3:4] <- path_names[4:3] # Move Influenza in front of Measles
path_names[5:10] <- path_names[c(6,7,8,5,9,10)]
path_names[11:27] <- path_names[c(20,23,11:19,21,22,24:27)]

pathway_cond <- pathway_cond[pathway_cond$Term %in% path_names,]
pathway_cond$log_pval <- -log10(pathway_cond$PValue)

pathway_cond$ct <- factor(pathway_cond$ct, levels = celltype_name)
pathway_cond$Term <- factor(pathway_cond$Term, levels = path_names)

pdf(paste0("Images/dotplot_enriched_pathway_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 14, height = 10)
ggplot(pathway_cond, aes(x = ct, y = Term)) + 
  geom_point(aes(color = log_pval, size = 1/Rank), alpha = 0.5) +
  scale_y_discrete(limits=rev) +
  scale_fill_gradient(low = "#132B43", high = "#56B1F7") + 
  labs(x = "Cell Type", y = "Pathway",color = "-log10(pval)", size = "1/Rank") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), 
        #change legend title font size
        legend.text = element_text(size=20),
        # panel.grid = element_blank(),
        # panel.background =element_blank(),
        # panel.border = element_blank()
        ) + 
  guides(fill=guide_legend(title="-log10(pval)"))
dev.off()


xtable(pathway_cond,digits = 3)
```

## Draw the heatmap of treatment effects by `heatmap3.R` and `pheatmap`

Auxiliary function to draw heatmaps by `heatmap3.R`
```{r}
source("../../heatmap3.R")
scale01 <- function(x, low = min(x), high = max(x)) {
  x <- (x - low)/(high - low)
  x
}

draw_keys <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL){
  if(is.null(color_key) & is.null(break_effects)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(10)
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }else if(is.null(color_key)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(length(break_effects) - 1)
  }else if(is.null(break_effects)){
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }

  z <- seq(min(break_effects), max(break_effects), length = length(color_key))
  image(z = matrix(z, ncol = 1), col = color_key, breaks = break_effects, xaxt = "n", yaxt = "n")
  lv <- pretty(break_effects)
  xv <- scale01(as.numeric(lv), min(break_effects), max(break_effects))
  axis(1, at = xv, labels = lv, cex.axis = 2.5)
  mtext(side = 1, "Value", line = 3.5, cex = 3)
  title(main = "Color Key", cex.main = 3)

}

heatmap_effects <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL, ...){

  if(is.null(color_key) & is.null(break_effects)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(10)
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }else if(is.null(color_key)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(length(break_effects) - 1)
  }else if(is.null(break_effects)){
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }

  out_fig <- heatmap.3(effects_matrix,
                       dendrogram = "row",#with cluster tree
                       Rowv = TRUE, Colv = FALSE,
                       # labRow = FALSE, labCol = FALSE,
                       ColSideColors = color_bar,
                       lmat=rbind(c(5,4),c(0,1), c(3,2)),#1=heatmap, 2=row dendogram, 3=col dendogram, 4= key
                       lhei=c(0.3,0.4,3.6),
                       lwid = c(0.3,3),
                       col=color_key, breaks = break_effects, key = FALSE, ...)

  return(out_fig)

}
```


```{r, error=TRUE}
eta_ordered <- eta_est
for(t in 2:Num_Treatment){
  eta_ordered[,(t-1) * K_opt + 1:K_opt] <- eta_est[, (t-1) * K_opt + est_switch]
}

eta_organized <- eta_ordered
for(k in 1:K_opt){
  eta_organized[,(k-1) * Num_Treatment + 1:Num_Treatment] <- eta_ordered[,0:(Num_Treatment-1) * K_opt + k]
}

treatment_effects_by_celltype <- eta_organized[E_adj,]

####################
# Draw by pheatmap #
####################
# Color bar
cond_id <- paste(
  rep(celltype_name, each = Num_Treatment), 
  rep(1:Num_Treatment, K_opt), 
  sep = "_")

colnames(treatment_effects_by_celltype) <- cond_id

annotation_cond <- data.frame(
  Treatment = factor(rep(c("Healthy","Moderate","Severe"), K_opt)),
  CellType = factor(rep(celltype_name, each = Num_Treatment), 
                    levels = celltype_name))

rownames(annotation_cond) <- cond_id

# Specify the color of the annotation bar
color_by_treatment <- c("#ccebc5","#b3cde3","#fbb4ae")
color_by_celltype <- rainbow(K_opt)

color_ann_celltype <- color_by_celltype
names(color_ann_celltype) <- celltype_name

cond_colors = list(Treatment = c(Healthy = color_by_treatment[1],
                                Moderate = color_by_treatment[2],
                                Severe = color_by_treatment[3]),
                     CellType = color_ann_celltype)

# logmu_ordered <- alpha_est + beta_ordered + eta_ordered
pdf(paste0("Images/pheatmap_treatment_effects_by_celltype_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 8, height = 12)
pheatmap(treatment_effects_by_celltype,
         color = colorRampPalette(c("#1D78B2","#F2F2F2","#C4012D"))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE,
         annotation_col = annotation_cond,
         annotation_colors = cond_colors,
         show_colnames = FALSE,
         scale = "none") 
dev.off()

#####################
# Draw by heatmap.3 #
#####################
# range
break_combined <- seq(-10,10, length.out = 101)
colorsChoice <- colorRampPalette(c("#1D78B2","#F2F2F2","#C4012D"))
color_key <- colorsChoice(100)

# Color bar
color_bar <- cbind(rep(color_by_treatment,K_opt),
  rep(color_by_celltype, each = Num_Treatment))

jpeg(paste0("Images/heatmap_treatment_effects_by_celltype_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 480, height = 960, quality = 100)
heat_logmu <- heatmap_effects(treatment_effects_by_celltype,
                              color_bar,
                              break_effects = break_combined,
                              labRow = FALSE, labCol = FALSE,
                              color_key = color_key)
dev.off()

jpeg(paste0("Images/colorkey_treatment_effects_by_celltype_v",ver,".jpg"),width = 480, height = 240)
draw_keys(treatment_effects_by_celltype, 
          color_key = color_key,
          break_effects = break_combined)
dev.off()

```

Draw the heatmap of logarithm expression levels by `pheatmap`
```{r}
# Draw the heatmap of mean expression levels in each cell type and each treatment
beta_ordered <- beta_est[,est_switch]
eta_ordered <- eta_est
for(t in 2:Num_Treatment){
  eta_ordered[,(t-1) * K_opt + 1:K_opt] <- eta_est[, (t-1) * K_opt + est_switch]
}

logmu_ordered <- eta_ordered
eta_organzied <- eta_est

for(k in 1:K_opt){
  for(t in 1:Num_Treatment){
    logmu_ordered[,(k-1) * Num_Treatment + t] <- alpha_est + beta_ordered[, k] + eta_ordered[, (t-1) * K_opt + k]
    
    eta_organzied[, (k-1) * Num_Treatment + t] <- eta_ordered[, (t-1) * K_opt + k]
  }
}

celltype_label <- paste0(rep(celltype_name,each = Num_Treatment),"_",rep(c("Healthy","Moderate","Severe"),K_opt))

colnames(logmu_ordered) <- celltype_label
# rownames(logmu_ordered) <- gene_list
rownames(logmu_ordered) <- NULL

# logmu_ordered <- alpha_est + beta_ordered + eta_ordered
pdf(paste0("Images/heatmap_logmu_ordered_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_ordered, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

pdf(paste0("Images/heatmap_logmu_ordered_rowcluster_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_ordered, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2))
dev.off()
```

Draw heatmap for intrinsic genes and cell-type-specific DE genes
```{r}
intrinsic_index <- which(D_adj)
logmu_intri <- logmu_ordered[intrinsic_index,]

intrinsic_genes <- gene_list[intrinsic_index]
# rownames(logmu_intri) <- intrinsic_genes
rownames(logmu_intri) <- NULL
colnames(logmu_intri) <- celltype_label

# Draw heatmap for all intrinsic genes
pdf(paste0("Images/heatmap_logmu_intri_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_intri, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

# Heatmap of cell-type-specific DE genes
rownames(logmu_ordered) <- gene_list
rownames(eta_organzied) <- gene_list
E_ordered <- E_combinded[, est_switch]

for(k in 1:K_opt){
  
DE_index <- which(E_ordered[,k])

logmu_celltype <- logmu_ordered[DE_index,(k-1) * Num_Treatment + 1:Num_Treatment]
colnames(logmu_celltype) <- c("Healthy", "Moderate", "Severe")

pdf(paste0("Images/heatmap_celltype_DE_",celltype_name[k],"_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_celltype, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

eta_celltype <- eta_organzied[DE_index,(k-1) * Num_Treatment + 1:Num_Treatment]
colnames(eta_celltype) <- c("Healthy", "Moderate", "Severe")

pdf(paste0("Images/heatmap_eta_DE_",celltype_name[k],"_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(eta_celltype, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-5,5,0.1),
         cluster_cols = FALSE) 
dev.off()

}
```



<!-- Heatmap for the log-scale mean expression levels---$\alpha_{g} + \beta_{gk}$ -->
<!-- ```{r heat_mu, error = TRUE} -->

<!-- beta_ordered <- beta_est[, est_switch] -->

<!-- logmu_ordered <- alpha_est + beta_ordered -->

<!-- break_mu <- seq(-0.3,4.1, length.out = 8) -->
<!-- color_by_celltype<-c("#F88A7E", "#FFD87D", "#ABD978", "#8097D3", "#9C7ACE") -->

<!-- jpeg(paste0("Images/heatmap_logmu_est_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 480, height = 960, quality = 100) -->
<!-- heat_logmu <- heatmap_effects(logmu_est, color_by_celltype, break_effects = break_mu) -->
<!-- dev.off() -->


<!-- pheatmap(adt_celltype,  -->
<!--          cluster_cols = FALSE, -->
<!--          cluster_rows = FALSE, -->
<!--           scale = "none")  -->
<!-- ``` -->


# Differential abundance
Load the MC samples of cell type labels and switch labels to be consistent with true cell type labels
```{r load_w}
w_MC <- read.table(paste0(dir_inference,"w_MC.txt"))

names(est_switch) <- 1:K_opt
label_switch <- as.numeric(names(sort(est_switch)))
w_MC <- matrix(label_switch[unlist(w_MC)], ncol = 10)
pi_ordered <- pi_est[,est_switch]
```


Obtain the Louis estimator of $\pi_{sk}$
```{r Louis}
# function to obtain the Louis estimators of cell type proportion Pi_{sk}
Louis_variance_MCESM <- function(cell_proportion, cell_labels_MC){
  
  if(is.list(cell_proportion)){
    cell_proportion <- unlist(cell_proportion)
  }
  
  n_rep <- ncol(cell_labels_MC)
  K <- length(cell_proportion)
  Km1 <- length(cell_proportion) - 1
  
  sum_w <- matrix(NA, K, n_rep)
  for(r in 1:n_rep){
    for(k in 1:K){
      sum_w[k,r] <- sum(cell_labels_MC[,r]==k)
    }
  }
  
  # Add 0.01 for singular values
  sum_w <- sum_w + 0.01
  
  #print(sum_w)
  
  first_der <- rep(0, Km1)
  first_der_cross <- matrix(0, Km1, Km1)
  second_der <- matrix(0, Km1, Km1)
  
  for(r in 1:n_rep){
    temp_first <- sum_w[1:(K - 1),r]/cell_proportion[1:(K-1)] - sum_w[K]/cell_proportion[K]
    first_der <- first_der + temp_first
    first_der_cross <- first_der_cross + temp_first %*% t(temp_first)
    second_der <- second_der - 
      diag(sum_w[1:(K - 1),r]/(cell_proportion[1:(K-1)])^2) - 
      sum_w[K,r]/(cell_proportion[K])^2
  }
  
  first_der <- first_der/n_rep
  first_der_cross <- first_der_cross/n_rep
  second_der <- second_der/n_rep
  
  obs_variance <- -second_der + first_der_cross - first_der %*% t(first_der)
  obs_variance <- solve(obs_variance)
  
  return(obs_variance)
}
```

Conduct differential abundance inference
```{r DA}
Diff.Abundance <- function(.pi, w, meta, ref = ncol(.pi), dim = c("Treat", "Batch", "Pair"), subset = NULL){
  
  .K <- ncol(.pi)
  .S <- nrow(.pi)
  s_infor <- meta$sample
  .cname <- colnames(.pi)
  .cname <- .cname[-ref]
  # browser()
  
  if(dim == "Treat"){
      # get the indices of each cell and the number of treatments
      d_infor <- factor(meta$treatment)
    }else if(dim == "Batch"){
      d_infor <- factor(meta$batch)
    }else if(dim == "Pair"){
      d_infor <- factor(meta$pair)
    }
    
    if(is.null(subset)){

      .dname <- levels(d_infor)
      .d <- length(.dname)
      .dsub <- 1:.d

    }else{

      .dsub <- subset
      .d <- length(subset)
      .dname <- levels(d_infor)[subset]

    }

    # Sample_set stores samples belonging to each treatment
    Sample_set <- list()
    for (j in 1:.d) {
      Sample_set[[j]] <- unique(s_infor[as.numeric(d_infor) == .dsub[j]])
    }

    res <- matrix(NA, .d * (.d - 1) / 2, 2 * .K)
    row_names <- NULL
    
    # compute Louis' estimator
    lvar <- array(NA, dim = c(.S, .K - 1, .K - 1))
    
    # put the reference to the last column
    if(ref != .K){
      .pi <- cbind(.pi[,-ref] , .pi[,ref])
      pos_ref <- which(w == ref)
      pos_lat <- which(w > ref)
      w[pos_ref] <- .K
      w[pos_lat] <- w[pos_lat] - 1
    }
    
    for(s in 1:.S){
      cell_index <- which(s_infor==s)
      lvar[s,,] <- Louis_variance_MCESM(.pi[s,],w[cell_index,]) 
    }
    
    index <- 1
    for (j1 in 1:(.d - 1)) {
      for (j2 in (j1+1):.d) {

        set1 <- Sample_set[[j1]]
        set2 <- Sample_set[[j2]]

        ns1 <- length(set1)
        ns2 <- length(set2)

        # Difference in proportion
        if(ns1 > 1){
          pi_mean_1 <- apply(.pi[set1, ], 2, mean)
        }else{
          pi_mean_1 <- .pi[set1, ]
        }
        
        if(ns2 > 1){
          pi_mean_2 <- apply(.pi[set2, ], 2, mean)
        }else{
          pi_mean_2 <- .pi[set2, ]
        }
          
        pi_dif <- pi_mean_1 - pi_mean_2

        # Compute within-group covariance
        Var_within <- matrix(0, .K - 1, .K - 1)
        for (s in set1) {
          Var_within <- Var_within + lvar[s, ,] / ns1 ^ 2
        }

        for (s in set2) {
          Var_within <- Var_within + lvar[s, ,] / ns2 ^ 2
        }

        # Compute between-group covariance
        Var_est <- Var_within
        
        if(ns1 > 1){
          Var_est <- Var_est + cov(.pi[set1, 1:(.K - 1)])/ns1
        }
        
        if(ns2 > 1){
          Var_est <- Var_est + cov(.pi[set2, 1:(.K - 1)])/ns2
        }

        # test statistics
        stat_celltype <- pi_dif[1:(.K - 1)] / sqrt(diag(Var_est))
        stat_overall <- t(pi_dif[1:(.K - 1)]) %*% solve(Var_est) %*% pi_dif[1:(.K - 1)]

        # pval
        p_celltype <- 2 * (1 - pnorm(abs(stat_celltype)))
        p_overall <- pchisq(stat_overall, df = .K - 1, lower.tail = FALSE)

        # # adjust by BH
        # p_adj <- p.adjust(p_celltype, method = "BH")

        res[index, 2 * 1:.K - 1] <- c(stat_celltype, stat_overall)
        # res[index, 2 * 1:.K] <-  c(p_adj, p_overall)
        res[index, 2 * 1:.K] <-  c(p_celltype, p_overall)
        
        row_names <- c(row_names, paste(.dname[j1], "vs", .dname[j2]))

        index <- index + 1
      }
    }
    
  
  rownames(res) <- row_names
  colnames(res) <- paste(rep(c(.cname,"Overall"),each = 2),rep(c("stat", "pval"),.K),sep = ":")
  
  return(res)
}

colnames(pi_ordered) <- celltype_name
meta_da <- data.frame(batch = metadata$Batch, 
                      treatment = factor(metadata$Severity), 
                      pair = btp_ind[,3], 
                      sample = btp_ind[,4])

# Diff.Abundance(pi_ordered, w_MC, meta = metadata, ref = 1, dim = "Treat", subset = c(1,2), alg = "MCESM")
# 
# # Batch 1 in treatment 1, 2 and 3
# DA_batch1 <- Diff.Abundance(pi_ordered, w_MC, meta = meta_da, ref = K_opt, dim = "Pair", subset = c(1,2,3))
# round(DA_batch1, digits = 4)
# 
# # Batch 2 in treatment 1, 2 and 3
# DA_batch2 <- Diff.Abundance(pi_ordered, w_MC, meta = meta_da, ref = K_opt, dim = "Pair", subset = c(4,5,6))
# round(DA_batch2, digits = 4)

# Two batches across treatment 1, 2 and 3
DA_treat <- Diff.Abundance(pi_ordered, w_MC, meta = meta_da, ref = K_opt, dim = "Treat")
round(DA_treat, digits = 4)


xtable(DA_treat, digits = 3)

```

# Correct batch effects and visualize the corrected read counts by UMAP
```{r correct}
adjusted_values <- function(ReadCount, Indicators, .K,
                            .alpha, .beta, .eta, .nu, .delta, .phi, .w){
  CorrectedCount <- ReadCount
  N <- ncol(ReadCount)
  for(i in 1:N){
    
    b <- Indicators[i,1]
    t <- Indicators[i,2]
    w <- .w[i]
    
    # percentile
    px <- pnbinom(ReadCount[,i], size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i]))
    pxminus1 <- pnbinom(ReadCount[,i] - 1, size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i]))
    
    # get the aligned percentile
    local_u <- runif(G) * (px - pxminus1) + pxminus1
    local_u <- ifelse(local_u > 0.9999, 0.9999, local_u)
    
    # obtain the quantile
    CorrectedCount[,i] <- qnbinom(local_u, size = .phi[,1], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w]))
    
    if(i %% 100 == 0){
      print(paste("Finish the correction of", i, "cells..."))
      
    }
  }
  return(CorrectedCount)
}

# x_imputed <- read.table(paste0(dir_inference,"imputed_count.txt"))

start_time<-Sys.time()
message("Calculate corrected read counts:")
x_corrected <-adjusted_values(y_obs, btp_ind, K_opt,
                             alpha_est, beta_est, eta_est,nu_est,delta_est,phi_est,w_est)
write.table(x_corrected, file = paste0("K",K_opt,"_r",r_opt,"/Inference_K",K_opt,"/corrected_count.txt"), row.names = FALSE, col.names = FALSE)
end_time<-Sys.time()
running_time<-difftime(end_time, start_time, units = "mins")
message("It takes ",running_time," mins to calculate the corrected data.")

rownames(metadata) <- paste0(metadata$Sample_id, metadata$Barcode)

save.image("0531CorrectedReadCounts.RData")
```

<!-- Draw UMAP and Dotplot for marker genes by DIFseq -->
<!-- ```{r UMAP} -->
<!-- x_corrected <- read.table(paste0(dir_inference,"corrected_count.txt")) -->
<!-- colnames(x_corrected) <- metadata$Sample -->
<!-- rownames(x_corrected) <- gene_list -->
<!-- rownames(metadata) <- metadata$Sample -->

<!-- Corrected_DIFseq <- CreateSeuratObject(counts = log1p(x_corrected), meta.data = metadata, project = paste0(proj,"_corrected"))  -->
<!-- # Corrected_DIFseq <- NormalizeData(Corrected_DIFseq) -->

<!-- # scaling -->
<!-- Corrected_DIFseq <- ScaleData(Corrected_DIFseq, features = gene_list) -->

<!-- # Run PCA -->
<!-- Corrected_DIFseq <- RunPCA(Corrected_DIFseq, features = gene_list) -->

<!-- ElbowPlot(Corrected_DIFseq, ndims = 30) -->

<!-- Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, reduction = "pca",  -->
<!--                                dims = 1:20, min.dist = 0.5, n.neighbours = 100) -->
<!-- # UMAP_Seurat <- Corrected_DIFseq[["umap"]]@cell.embeddings -->

<!-- DIFseq_celltype <- factor(label_switch[w_est]) -->
<!-- levels(DIFseq_celltype) <-  c("Alpha", "Beta", "Delta&Gamma", "Acinar", "Ductal", "Other") -->
<!-- Corrected_DIFseq$DIFseq_cluster <- DIFseq_celltype -->

<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "DIFseq_cluster",label = TRUE) -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "CellType", label = TRUE) -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "Study") -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "Disease") -->
<!-- ``` -->


<!-- Draw feature plots for known marker genes -->
<!-- ```{r feature_plot} -->
<!-- marker_genes <- c("GCG", "INS", "PPY", "SST", "PRSS1", "KRT19") -->
<!-- FeaturePlot(Corrected_DIFseq, features = marker_genes, min.cutoff = "q9") -->
<!-- ``` -->

<!-- ```{r} -->

<!-- DotPlot(Corrected_DIFseq, features = marker_genes, cols = c("blue", "red"), dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis() -->
<!-- ``` -->

## Dot plot of the average gene expression levels and proportions

```{r}
library(dplyr)

marker_genes <- c("IFI27", "IFITM3", "ISG15")

# Adjust cell type labels
names(est_switch) <- 1:K_opt
label_switch <- as.numeric(names(sort(est_switch)))
w_ordered <- label_switch[w_est]

# gene <- "ISG15"

df_marker <- NULL

for(gene in marker_genes){
  
  log_mean_counts <- rep(NA, K_opt * Num_Treatment)
  expr_prop <- rep(NA, K_opt * Num_Treatment)
  
  corrected_count <- x_corrected[gene_list == gene, ]
  
  df_count <- data.frame(DIFseq_type = celltype_name[w_ordered],
                         Treatment = metadata$Severity,
                         Count = corrected_count)
  
  
  df_summary <- df_count %>% 
    group_by(DIFseq_type, Treatment) %>%
    summarise(LogMeanExp = mean(log1p(Count)), 
              ExprProp = mean(Count > 0))

  
  df_summary$Marker <- gene
  
  df_marker <- rbind(df_marker, df_summary)
}

df_marker$DIFseq_type <- factor(df_marker$DIFseq_type, levels = celltype_name)

pdf(file = paste0("Images/Dotplot_IFN_genes_",proj,"_v",ver,".pdf"), width = 14, height = 6)
ggplot(df_marker, aes(x = DIFseq_type, y = Treatment)) + 
  geom_point(aes(color = LogMeanExp, size = ExprProp), alpha = 0.8) + facet_grid(Marker ~.) + 
  # scale_y_discrete(limits=rev) +
  scale_color_gradient(low = "#ffeda0", high = "#e31a1c") + 
  labs(x = "Cell Type", y = "Treatment",color = "Average Expression", size = "Precent Expressed") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), 
        legend.text = element_text(size=20),
        ) + 
  guides(fill=guide_legend(title="-log10(pval)"))
dev.off()
```


Other marker genes
```{r}
marker_genes <- grep(pattern = "^IF", gene_list, value = TRUE)

marker_genes <- marker_genes[16:22]

# Adjust cell type labels
names(est_switch) <- 1:K_opt
label_switch <- as.numeric(names(sort(est_switch)))
w_ordered <- label_switch[w_est]

# gene <- "ISG15"

df_marker <- NULL

for(gene in marker_genes){
  
  log_mean_counts <- rep(NA, K_opt * Num_Treatment)
  expr_prop <- rep(NA, K_opt * Num_Treatment)
  
  corrected_count <- x_corrected[gene_list == gene, ]
  
  df_count <- data.frame(DIFseq_type = celltype_name[w_ordered],
                         Treatment = metadata$Severity,
                         Count = corrected_count)
  
  
  df_summary <- df_count %>% 
    group_by(DIFseq_type, Treatment) %>%
    summarise(LogMeanExp = mean(log1p(Count)), 
              ExprProp = mean(Count > 0))

  
  df_summary$Marker <- gene
  
  df_marker <- rbind(df_marker, df_summary)
}

df_marker$DIFseq_type <- factor(df_marker$DIFseq_type, levels = celltype_name)

ggplot(df_marker, aes(x = DIFseq_type, y = Treatment)) + 
  geom_point(aes(color = LogMeanExp, size = ExprProp), alpha = 0.8) + facet_grid(Marker ~.) + 
  # scale_y_discrete(limits=rev) +
  scale_color_gradient(low = "#ffeda0", high = "#e31a1c") + 
  labs(x = "Cell Type", y = "Treatment",color = "ave(log(count + 1))", size = "Precent Expressed") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), 
        legend.text = element_text(size=20),
        ) + 
  guides(fill=guide_legend(title="-log10(pval)"))


```

<!-- ## Violin plot of IFN marker genes -->

<!-- ```{r} -->
<!-- library(dplyr) -->

<!-- ISG_genes <- which(gene_list == c("IFI27", "IFITM3", "ISG15")) -->

<!-- df_marker <- metadata -->

<!-- # Generate permutated cell type labels -->
<!-- names(est_switch) <- 1:K_opt -->
<!-- label_switch <- as.numeric(names(sort(est_switch))) -->
<!-- w_ordered <- label_switch[w_est] -->

<!-- df_marker$DIFseq_type <- celltype_name[w_ordered] -->

<!-- df_marker$IFI27 <- log1p(x_corrected[ISG_genes[1],]) -->
<!-- df_marker$IFITM3 <- log1p(x_corrected[ISG_genes[2],]) -->
<!-- df_marker$ISG15 <- log1p(x_corrected[ISG_genes[3],]) -->

<!-- df_marker$imputed_ISG15 <- unlist(imputed_ISG15) -->

<!-- ggplot(df_marker, aes(x=DIFseq_type, y=ISG15, fill=Severity)) + -->
<!--     geom_violin() + ylim(0,1) -->

<!-- ``` -->

## Auxiliary function
```{r UMAP_plot}
plot_UMAP<-function(umap_var,col,p_name,leg_name, shuffle = TRUE){

  if(shuffle){
    shuffle_label <- sample(1:nrow(umap_var), nrow(umap_var))
    umap_var <- umap_var[shuffle_label,]
    col <- col[shuffle_label]
  }

  # The image with legend
  jpeg(paste(p_name,"_with_legend.jpeg",sep=""),width = 1440, height = 1080)
  par(mar=c(5.1,6.1,4.1,2.1))
  plot(umap_var,t="n",xaxt="n",yaxt="n",xlab="",ylab="")#main="tsne_uncorrected_by_batch")
  axis(1,cex.axis=6,line=2.5,tick = F)#plot the x axis
  axis(2,cex.axis=6,tick = F)#plot the y axis
  points(umap_var,pch=19 ,col= col,cex=3)
  legend("bottomright",legend=leg_name[,1],pch=19,col=leg_name[,2],cex=2)
  dev.off()

  # The image without legend
  jpeg(paste(p_name,".jpeg",sep=""),width = 1440, height = 1080)
  par(mar=c(5.1,6.1,4.1,2.1))
  plot(umap_var,t="n",xaxt="n",yaxt="n",xlab="",ylab="")#main="tsne_uncorrected_by_batch")
  axis(1,cex.axis=6,line=2.5,tick = F)#plot the x axis
  axis(2,cex.axis=6,tick = F)#plot the y axis
  points(umap_var,pch=19 ,col= col,cex=3)
  dev.off()

}
```

## Draw Violin plot for the corrected counts of IFN genes

```{r}
# 

```

<!-- ## Setting color palettes for batch, cell type and treatment -->
<!-- ```{r coloring} -->
<!-- color_by_batch<-viridis(B) -->
<!-- color_by_celltype<-rainbow(K_opt) -->
<!-- # color_by_treatment<-c( "#4C00FF80","#00FF4D80","#FFFF0080") -->

<!-- # Point color -->
<!-- study_name <- unique(metadata$Batch) -->
<!-- treat_name <- unique(metadata$Severity) -->

<!-- b_ind <- factor(metadata$Study, levels = study_name) -->
<!-- t_ind <- factor(metadata$Disease, levels = treat_name) -->
<!-- celltype_ind <- metadata$CellType -->


<!-- cell_color_by_batch <- color_by_batch[btp_ind[,1]] -->
<!-- cell_color_by_celltype <- color_by_celltype[w_est] -->
<!-- cell_color_by_treatment <- color_by_treatment[btp_ind[,2]] -->

<!-- # Legend -->
<!-- legend_batch <- cbind(study_name,color_by_batch) -->
<!-- legend_celltype <- cbind(1:K_opt,color_by_celltype) -->
<!-- legend_treatment <- cbind(treat_name,color_by_treatment) -->
<!-- ``` -->


<!-- ## UMAP for raw count data -->
<!-- ```{r UMAP_raw, eval = FALSE} -->
<!-- Raw_simulation <- CreateSeuratObject(counts = y_obs, meta.data = metadata, project = paste0(proj,"_raw")) -->

<!-- Raw_simulation <- ScaleData(Raw_simulation, features = gene_list) -->
<!-- Raw_simulation <- RunPCA(Raw_simulation, features = gene_list) -->

<!-- ElbowPlot(Raw_simulation, ndims= 50) -->

<!-- ``` -->

<!-- ```{r plot_raw, eval = FALSE} -->
<!-- set.seed(1234) -->
<!-- Raw_simulation <- RunUMAP(Raw_simulation, dims = 1:25, min.dist = 0.5, n.neighbours = 100) -->

<!-- # Coordinate -->
<!-- UMAP_unc <- Raw_simulation[["umap"]]@cell.embeddings -->

<!-- # color by batch -->
<!-- method <- "Unc" -->
<!-- unc_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch") -->
<!-- plot_UMAP(UMAP_unc,cell_color_by_batch,unc_by_batch,legend_batch) -->

<!-- # color by cell type -->
<!-- unc_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype") -->
<!-- plot_UMAP(UMAP_unc,cell_color_by_celltype,unc_by_celltype,legend_celltype) -->

<!-- # color by treatment -->
<!-- unc_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment") -->
<!-- plot_UMAP(UMAP_unc,cell_color_by_treatment,unc_by_treatment,legend_treatment) -->
<!-- ``` -->

<!-- ## UMAP for the corrected count data by DIFseq -->
<!-- ```{r PCA_correct, eval = FALSE} -->
<!-- Corrected_DIFseq <- CreateSeuratObject(counts = x_corrected, meta.data = metadata, project = "DIFseq_corrected") -->
<!-- # scaling -->
<!-- Corrected_DIFseq <- ScaleData(Corrected_DIFseq, features = gene_list) -->
<!-- # Run PCA -->
<!-- Corrected_DIFseq <- RunPCA(Corrected_DIFseq, features = gene_list) -->
<!-- ElbowPlot(Corrected_DIFseq, ndims= 50) -->
<!-- ``` -->

<!-- ```{r UMAP, eval = FALSE} -->
<!-- # Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, dims = 1:30) -->
<!-- Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, dims = 1:25, min.dist = 0.5, n.neighbours = 100) -->
<!-- UMAP_DIFseq <- Corrected_DIFseq[["umap"]]@cell.embeddings -->

<!-- method <- "DIFseq" -->
<!-- # color by batch -->
<!-- DIFseq_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch") -->
<!-- plot_UMAP(UMAP_DIFseq,cell_color_by_batch,DIFseq_by_batch,legend_batch) -->

<!-- # color by cell type -->
<!-- DIFseq_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype") -->
<!-- plot_UMAP(UMAP_DIFseq,cell_color_by_celltype,DIFseq_by_celltype,legend_celltype) -->

<!-- # color by treatment -->
<!-- DIFseq_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment") -->
<!-- plot_UMAP(UMAP_DIFseq,cell_color_by_treatment,DIFseq_by_treatment,legend_treatment) -->

<!-- ``` -->

<!-- ## Distribution of antibodies in different clusters -->
<!-- ```{r ADT_levels, eval = FALSE} -->

<!-- save.image("0406UMAP_covid_sc.RData") -->
<!-- colnames(adt_count) <- colnames(y_obs) -->

<!-- # Load features -->
<!-- features_all <- read.table("../RawData/GSE155673/GSE155673_features.tsv.gz", sep = "\t") -->
<!-- colnames(features_all) <- c("Ensembl", "Symbol", "Category") -->
<!-- adt_symbol <- features_all$Symbol[match(rownames(adt_count),features_all$Ensembl)] -->


<!-- adt_name <- sapply(strsplit(adt_symbol,"--"),`[[`,1) -->
<!-- adt_name[36:39] <- paste0(adt_name[36:39], 1:4) -->

<!-- rownames(adt_count) <- adt_name -->

<!-- adt_obj <- CreateAssayObject(adt_count) -->
<!-- Corrected_DIFseq[["ADT"]] <- adt_obj -->

<!-- DefaultAssay(Corrected_DIFseq) <- "ADT" -->
<!-- Corrected_DIFseq <- NormalizeData(Corrected_DIFseq, normalization.method = "CLR", margin = 2) -->

<!-- Corrected_DIFseq$DIFseq_cluster <- w_est -->

<!-- DotPlot(Corrected_DIFseq, features = rownames(Corrected_DIFseq), cols = c("white", "red"), dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis() -->

<!-- Corrected_DIFseq <- ScaleData(Corrected_DIFseq) -->

<!-- jpeg(paste0("Images/Heatmap_adt_",method,"_",proj,"_v",ver,"_K",K_opt,".jpg"), -->
<!--      width = 1440, height = 1080) -->
<!-- DoHeatmap(Corrected_DIFseq, features = rownames(Corrected_DIFseq), group.by = "DIFseq_cluster") -->
<!-- dev.off() -->

<!-- # n_adt <- nrow(adt_count) -->
<!-- # for(adt in 1:n_adt){ -->
<!-- #    -->
<!-- #   p_name <- paste0("Images/Feature_plots_",method,"_",proj,"_v",ver,"_K",K_opt,"_",) -->
<!-- #   jpeg(paste(p_name,".jpeg",sep=""),width = 1440, height = 1080) -->
<!-- #   dev.off() -->
<!-- # } -->
<!-- #  -->
<!-- #  -->
<!-- #  -->
<!-- #  -->
<!-- # FeaturePlot(Corrected_DIFseq, "CD3--UCHT1-TSA") + ggtitle("CD3") -->
<!-- # DimPlot(Corrected_DIFseq, group.by = "Batch") -->
<!-- # DefaultAssay(scRNA) -->
<!-- # adt_count -->



<!-- ``` -->

<!-- ## UMAP for the corrected data by Seurat and MiloR -->
<!-- ```{r UMAP_comparison, eval = FALSE} -->
<!-- # Seurat -->
<!-- load(paste0("04UMAP_coord_Seurat_",proj,"_v",ver,".RData")) -->

<!-- method <- "Seurat" -->
<!-- # color by batch -->
<!-- Seurat_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch") -->
<!-- plot_UMAP(UMAP_Seurat,cell_color_by_batch,Seurat_by_batch,legend_batch) -->

<!-- # color by cell type -->
<!-- Seurat_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype") -->
<!-- plot_UMAP(UMAP_Seurat,cell_color_by_celltype,Seurat_by_celltype,legend_celltype) -->

<!-- # color by treatment -->
<!-- Seurat_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment") -->
<!-- plot_UMAP(UMAP_Seurat,cell_color_by_treatment,Seurat_by_treatment,legend_treatment) -->

<!-- # Seurat -->
<!-- load(paste0("04UMAP_coord_MiloR_",proj,"_v",ver,".RData")) -->

<!-- method <- "MiloR" -->
<!-- # color by batch -->
<!-- MiloR_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch") -->
<!-- plot_UMAP(UMAP_MiloR,cell_color_by_batch,MiloR_by_batch,legend_batch) -->

<!-- # color by cell type -->
<!-- MiloR_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype") -->
<!-- plot_UMAP(UMAP_MiloR,cell_color_by_celltype,MiloR_by_celltype,legend_celltype) -->

<!-- # color by treatment -->
<!-- MiloR_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment") -->
<!-- plot_UMAP(UMAP_MiloR,cell_color_by_treatment,MiloR_by_treatment,legend_treatment) -->
<!-- ``` -->


```{r save}
Today <- Sys.Date()
save.image(paste0(paste0(Today,"Results_DIFseq_",proj,"_v",ver,".RData")))
```



<!-- ### Checking -->

<!-- Six cell-type-specific DE genes fail to be detected by controlling FDR at 0.05. Let's take a look the estimated FDR. -->

<!-- Auxiliary functions to compute FDR -->
<!-- ```{r} -->
<!-- .fdrDEindicator <- function(xi, kappa){ -->

<!--   ind_intr <- xi <= kappa -->
<!--   fdr <- sum(xi[ind_intr])/sum(ind_intr) -->

<!--   return(fdr) -->
<!-- } -->

<!-- #calculate the DE posterior probability threshold -->
<!-- .postprob_DE_thr_fun <- function(xi, fdr_threshold=0.05){ -->

<!--   kappa_fdr_matr <- NULL -->
<!--   kappa_set <- sort(unique(xi)) -->

<!--   kappa_ind <- which(kappa_set < 0.5 & kappa_set > fdr_threshold) -->

<!--   for(i in kappa_ind){ -->

<!--     kappa <- kappa_set[i] -->
<!--     fdr <- .fdrDEindicator(xi, kappa=kappa) -->

<!--     if(fdr > fdr_threshold){ -->
<!--       break -->
<!--     } -->
<!--   } -->

<!--   kappa <- kappa_set[i-1] -->
<!--   return(kappa) -->
<!-- } -->

<!-- #Estimate intrinsic gene indicators -->
<!-- .estimate_IG_indicators <- function(xi, postprob_DE_threshold = 0.5){ -->

<!--   EstL <- xi -->
<!--   EstL[xi >= postprob_DE_threshold] <- 0 -->
<!--   EstL[xi <= postprob_DE_threshold] <- 1 -->
<!--   # message("The output format is a matrix.\n") -->
<!--   # message(paste0("Each row represents a gene, and each column", -->
<!--   #               " corresponds to a cell type from 2 to K\n")) -->
<!--   return(EstL) -->
<!-- } -->

<!-- #Intrinsic gene index -->
<!-- .IG_index <- function(EstIGindicators){ -->
<!--   ind <- which(rowSums(EstIGindicators) > 0) -->
<!--   message(c(length(ind), " intrinsic genes are found.\n")) -->
<!--   message("The output format is a vector implying the intrinsic gene", -->
<!--           " indices.\n") -->
<!--   return(ind) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- # Take exponential to obatin Pr(L=0) or Pr(J=0) -->
<!-- PrL_est <- exp(logPrL_est) -->
<!-- PrJ_est <- exp(logPrJ_est) -->

<!-- colnames(PrL_est) <- paste0("K",1:K_opt) -->
<!-- colnames(PrJ_est) <- paste0("T",rep(1:Num_Treatment, each = K_opt),"K",rep(1:K_opt, Num_Treatment)) -->

<!-- pval_col <- cbind(PrL_est[,-1], PrJ_est[, K_opt + 1:(2 * K_opt)]) -->

<!-- xi_thres <- .postprob_DE_thr_fun(pval_col, 0.05) -->
<!-- DE_est <- .estimate_IG_indicators(pval_col, xi_thres) -->

<!-- D_est <- apply(DE_est[,1:(K_opt-1)], 1, sum) > 0 -->
<!-- num_intri <- sum(D_est) -->

<!-- J_est <- apply(DE_est[,K_opt - 1 + 1:(2*K_opt)], 1, sum) > 0 -->
<!-- num_DE <- sum(J_est) -->

<!-- .fdrDEindicator(pval_col, xi_thres) -->
<!-- ``` -->

<!-- The threshold is `xi_thres` after controlling FDR at level 0.05, so the cell type or treatment effects with the corresponding posterior probability greater than `1-xi_thres` are regarded as differential expression. -->

<!-- ## Obtain corrected read count data  -->
<!-- ```{r} -->
<!-- library(RColorBrewer) -->
<!-- library(ggplot2) -->
<!-- library(edgeR) -->
<!-- # library(Rtsne) -->
<!-- # library(umap) -->

<!-- # Function to output the plot to a jpeg -->
<!-- Draw_scatter_plot <- function(Dat, name = "PC_plots", type = "PC", color, labels){ -->

<!--   dat_frame <- data.frame(Var1 = Dat[,1],  -->
<!--                           Var2 = Dat[,2],  -->
<!--                           col = labels) -->

<!--   # permute samples to avoid fully overlapping -->
<!--   N <- nrow(Dat) -->
<!--   dat_frame <- dat_frame[sample(1:N, size = N),] -->

<!--   jpeg(paste0(name,".jpg"),width = 16, height = 12) -->
<!--   p <- ggplot(dat_frame, aes(x= Var1, y= Var2, colour= col)) + -->
<!--     geom_point(size=4) + theme_classic() + -->
<!--     scale_colour_manual(values = alpha(color,0.2)) + -->
<!--     xlab(paste(type,1)) + ylab(paste(type,2)) + -->
<!--     theme(axis.text.x = element_text(face = "bold", #color = "#993333",  -->
<!--                                      size = 44), #angle = 45), -->
<!--           axis.text.y = element_text(face = "bold", #color = "blue",  -->
<!--                                      size = 44),#, angle = 45)) -->
<!--           axis.title=element_text(size=48,face="bold"), -->
<!--           panel.background = element_rect(colour = "black",size = 2), -->
<!--           legend.position = "none") -->
<!--   print(p) -->
<!--   dev.off() -->
<!--   return(p) -->
<!-- } -->

<!-- # Function to correct read count data -->
<!-- adjusted_values <- function(ReadCount, Indicators, .K, -->
<!--                             .alpha, .beta, .eta, .nu, .delta, .phi, .w){ -->
<!--   CorrectedCount <- ReadCount -->
<!--   N <- ncol(ReadCount) -->
<!--   for(i in 1:N){ -->

<!--     b <- Indicators[i,1] -->
<!--     t <- Indicators[i,2] -->
<!--     w <- .w[i] -->

<!--     # percentile -->
<!--     px <- pnbinom(ReadCount[,i], size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i])) -->
<!--     pxminus1 <- pnbinom(ReadCount[,i] - 1, size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i])) -->

<!--     # get the aligned percentile -->
<!--     local_u <- runif(G) * (px - pxminus1) + pxminus1 -->
<!--     local_u <- ifelse(local_u > 0.9999, 0.9999, local_u) -->

<!--     # obtain the quantile -->
<!--     CorrectedCount[,i] <- qnbinom(local_u, size = .phi[,1], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w])) -->

<!--     if(i %% 100 == 0){ -->
<!--       print(paste("Finish the correction of", i, "cells...")) -->

<!--     } -->
<!--   } -->
<!--   return(CorrectedCount) -->
<!-- } -->

<!-- # 1) Correction -->
<!-- x_imputed <- read.table(paste0(dir_inference,"imputed_count.txt")) -->

<!-- # For test -->


<!-- start_time<-Sys.time() -->
<!-- message("Calculate corrected read counts:") -->
<!-- x_corrected <-adjusted_values(x_imputed, btp_ind, K_opt, -->
<!--                              alpha_est, beta_est, eta_est,nu_est,delta_est,phi_est,w_est) -->
<!-- write.table(x_corrected, file = "x_corrected.txt", row.names = FALSE, col.names = FALSE) -->
<!-- end_time<-Sys.time() -->
<!-- running_time<-difftime(end_time, start_time, units = "mins") -->
<!-- message("It takes ",running_time," mins to calculate the corrected data.") -->

<!-- colnames(x_corrected) <- paste0("Cells-",1:N) -->
<!-- rownames(x_corrected) <- paste0("Genes-",1:G) -->
<!-- rownames(metadata) <- paste0("Cells-",1:N) -->


<!-- # Draw t-SNE plot and UMAP for corrected read counts -->
<!-- library(Seurat) -->
<!-- Seuart_obj <- CreateSeuratObject(counts = x_corrected, meta.data = metadata, project = "sim_corrected")  -->

<!-- # Add DIFseq labels -->
<!-- w_factor <- factor(w_est, levels = est_switch, labels = colnames(pi_ordered)) -->
<!-- Seuart_obj$DIFseq_cluster <- w_factor -->

<!-- # scaling -->
<!-- Seuart_obj <- ScaleData(Seuart_obj, features = hvg_genes) -->

<!-- # Run PCA -->
<!-- Seuart_obj <- RunPCA(Seuart_obj, features = hvg_genes) -->
<!-- ElbowPlot(Seuart_obj, ndims= 50) -->

<!-- # Run UMAP -->
<!-- Seuart_obj <- RunUMAP(Seuart_obj, dims = 1:40) -->


<!-- # there are some errors in the source code such that X = Y + 1 -->
<!-- start_time<-Sys.time() -->
<!-- message("Calculate corrected read counts:") -->
<!-- p_infor <- rep(1:Num_pair, nbt) -->
<!-- btp_indicators <- cbind(b_infor,t_infor,p_infor) -->
<!-- x_corrected<-adjusted_values(x_imputed, btp_indicators, K_opt, -->
<!--                              alpha_est, beta_est, eta_est,nu_est,delta_est,phi_est,w_est) -->
<!-- write.table(x_corrected, file = "x_corrected.txt", row.names = FALSE, col.names = FALSE) -->
<!-- end_time<-Sys.time() -->
<!-- running_time<-difftime(end_time, start_time, units = "mins") -->
<!-- message("It takes ",running_time," mins to calculate the corrected data.") -->

<!-- # 2) set color patterns of difference cell types, batches and treatments -->
<!-- ## cell type -->
<!-- color_by_celltype <- brewer.pal(K_opt,"Set3") -->
<!-- celltype_factor <- factor(w) -->

<!-- ## batch -->
<!-- color_by_batch <- brewer.pal(B,"Set1") -->
<!-- batch_factor <- factor(b_infor) -->

<!-- ## treatment -->
<!-- color_by_treatment <- brewer.pal(Num_Treatment,"Spectral") -->
<!-- treatment_factor <- factor(t_infor) -->

<!-- # 2) Draw PCA plots -->
<!-- raw.pca <- prcomp(t(x_corrected), center = TRUE,scale. = TRUE, rank. = 50) -->
<!-- Draw_scatter_plot(raw.pca$x, name = paste0("../../Images/PCA_",proj,"_BUTseq_by_celltype_v",ver), -->
<!--                   type = "PC", color = color_by_celltype, labels = celltype_factor) -->

<!-- Draw_scatter_plot(raw.pca$x, name = paste0("../../Images/PCA_",proj,"_BUTseq_by_batch_v",ver), -->
<!--                   type = "PC", color = color_by_batch, labels = batch_factor) -->

<!-- Draw_scatter_plot(raw.pca$x, name = paste0("../../Images/PCA_",proj,"_BUTseq_by_treatment_v",ver), -->
<!--                   type = "PC", color = color_by_treatment, labels = treatment_factor) -->

<!-- # 3) Draw UMAP plot  -->
<!-- # ## 3.1 Draw on the raw count data -->
<!-- # set.seed(123) -->
<!-- # raw_umap <- umap(t(x_corrected)) -->
<!-- # Draw_scatter_plot(raw_umap$layout, name = paste0("../../Images/Direct_umap_",proj,"_BUTseq_by_celltype_v",ver), -->
<!-- #                   type = "UMAP", color = color_by_celltype, labels = celltype_factor) -->
<!-- #  -->
<!-- # Draw_scatter_plot(raw_umap$layout, name = paste0("../../Images/Direct_umap_",proj,"_BUTseq_by_batch_v",ver), -->
<!-- #                   type = "UMAP", color = color_by_batch, labels = batch_factor) -->
<!-- #  -->
<!-- # Draw_scatter_plot(raw_umap$layout, name = paste0("../../Images/Direct_umap_",proj,"_BUTseq_by_treatment_v",ver), -->
<!-- #                   type = "UMAP", color = color_by_treatment, labels = treatment_factor) -->


<!-- ## 3.2 Draw on selected PCs -->
<!-- ### select the number of PCs to be considered by the eblow plot -->
<!-- plot(raw.pca$sdev[1:50]) -->
<!-- raw_PCs <- raw.pca$x[,1:8] -->
<!-- set.seed(123) -->
<!-- raw_umap_PC <- umap(raw_PCs) -->
<!-- Draw_scatter_plot(raw_umap_PC$layout, name = paste0("../../Images/PCA_umap_",proj,"_BUTseq_by_celltype_v",ver), -->
<!--                   type = "UMAP", color = color_by_celltype, labels = celltype_factor) -->

<!-- Draw_scatter_plot(raw_umap_PC$layout, name = paste0("../../Images/PCA_umap_",proj,"_BUTseq_by_batch_v",ver), -->
<!--                   type = "UMAP", color = color_by_batch, labels = batch_factor) -->

<!-- Draw_scatter_plot(raw_umap_PC$layout, name = paste0("../../Images/PCA_umap_",proj,"_BUTseq_by_treatment_v",ver), -->
<!--                   type = "UMAP", color = color_by_treatment, labels = treatment_factor) -->

<!-- # 4) Draw PCA plot -->
<!-- # ## 4.1 Draw on the raw count data -->
<!-- # set.seed(123) -->
<!-- # tsne_uncorrected <- Rtsne(t(x_corrected)) -->
<!-- # Draw_scatter_plot(tsne_uncorrected$Y, name = paste0("../../Images/Direct_tsne_",proj,"_BUTseq_by_celltype_v",ver), -->
<!-- #                   type = "tSNE", color = color_by_celltype, labels = celltype_factor) -->
<!-- #  -->
<!-- # Draw_scatter_plot(tsne_uncorrected$Y, name = paste0("../../Images/Direct_tsne_",proj,"_BUTseq_by_batch_v",ver), -->
<!-- #                   type = "tSNE", color = color_by_batch, labels = batch_factor) -->
<!-- #  -->
<!-- # Draw_scatter_plot(tsne_uncorrected$Y, name = paste0("../../Images/Direct_tsne_",proj,"_BUTseq_by_treatment_v",ver), -->
<!-- #                   type = "tSNE", color = color_by_treatment, labels = treatment_factor) -->

<!-- ## 4.2 Draw tSNE plots based on PCs -->
<!-- set.seed(123) -->
<!-- PC_tsne_uncorrected <- Rtsne(raw_PCs) -->
<!-- Draw_scatter_plot(PC_tsne_uncorrected$Y, name = paste0("../../Images/PCA_tsne_",proj,"_BUTseq_by_celltype_v",ver), -->
<!--                   type = "tSNE", color = color_by_celltype, labels = celltype_factor) -->

<!-- Draw_scatter_plot(PC_tsne_uncorrected$Y, name = paste0("../../Images/PCA_tsne_",proj,"_BUTseq_by_batch_v",ver), -->
<!--                   type = "tSNE", color = color_by_batch, labels = batch_factor) -->

<!-- Draw_scatter_plot(PC_tsne_uncorrected$Y, name = paste0("../../Images/PCA_tsne_",proj,"_BUTseq_by_treatment_v",ver), -->
<!--                   type = "tSNE", color = color_by_treatment, labels = treatment_factor) -->
<!-- ``` -->
<!-- ## Draw UMAP -->

<!-- ## Comparison with Seurat and Milo -->
<!-- ```{r} -->

<!-- ``` -->




