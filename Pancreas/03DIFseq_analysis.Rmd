---
title: "Posterior inference for simulation_v67"
author: "Fangda, Song"
date: "2023-02-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r ver}
# source("heatmap3.R")
library(mclust)
library(bigmemory)
library(ggplot2)
library(Seurat)
library(viridis) # coloring for the heatmap of batch effects
library(patchwork)
library(xtable)

library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization

library(RColorBrewer)
library(pheatmap)

library(xtable)

proj <- "pancreas"
ver <- 161

if(!dir.exists("Images")){
  dir.create("Images")
}
```


## Draw BIC plot to select the optimal number of cell types
```{r BIC}
load(paste0("Model_selection_post_v",ver,".RData"))
K_sel <- 3:12
BIC_table <- summary_results[[1]]
BIC_values <- apply(BIC_table,1,min,na.rm=TRUE)

ind_min <- which.min(BIC_values)
K_opt <- K_sel[ind_min]
r_opt <- which.min(BIC_table[ind_min, ])

dir_inference <- paste0("K",K_opt,"_r",r_opt,"/Inference_K",K_opt,"/")

pdf(paste0("Images/BIC_plot_simulation_v",ver,".pdf"),width = 8, height = 8)
par(mar = c(5.1,6.1,4.1,2.1)) 
plot(K_sel,BIC_values,xlab= "K",ylab = "BIC",type="n",cex.axis=2,cex.lab=3)
points(K_sel,BIC_values,type="b",pch=19,cex=3)
dev.off()
```


```{r replication}
y_obs <- read.table(paste0("RawCountData/count_data_",proj,"_v",ver,".txt"))
y_obs <- as.matrix(y_obs)

# Load dimension
dim <- read.table(paste0("RawCountData/dim_",proj,"_v",ver,".txt"))
dim <- unlist(dim)
N <- dim[1]
S <- dim[2]
G <- dim[3]
B <- dim[4]
Num_Treatment <- dim[5]
P <- dim[6]
BT_pair <- matrix(dim[6 + 1:(3*P)], byrow = TRUE, nrow = P)
colnames(BT_pair) <- c("Batch", "Treatment", "n_bt")

# Load metadata
metadata <- read.table(paste0("RawCountData/metadata_",proj,"_v",ver,".txt"), header = TRUE)
# colnames(metadata) <- c("Batch", "Treatment", "CellType")
  
# Load the gene list
gene_list <- unlist(read.table(paste0("RawCountData/gene_list_",proj,"_v",ver,".txt"),stringsAsFactors = F))

# Add row and column names for the raw count data matrix
rownames(y_obs) <- gene_list
colnames(y_obs) <- metadata$Sample

# indices of cells
btp_ind <- read.table(paste0("RawCountData/tbinfor_",proj,"_v",ver,".txt"))
```
Finally, we select the 10th replicate of `K=6`.

## Running time
Here, we record the running time of the steps in the stochastic EM algorithm. Maybe we can draw a pie chart to show the proportions of each part.

```{r time}
time_con <- read.table(file = paste0(dir_inference,"time_consumption.txt"),header = FALSE)
colnames(time_con) <- c("E step for spike-and-slab priors","M step for pi",
                        "MCE step","SM step for gamma","SM step for abnep",
                        "M step for delta","M step for p and tau",
                        "Calculate the likelihood")
time_per_iter <- apply(time_con,2 ,mean)
time_percentage <- round(time_per_iter/sum(time_per_iter) * 100, digits = 2)
time_percentage

iter_infor <- unlist(read.table(paste0(dir_inference,"iter_infor.txt")))

iter_num <- nrow(time_con)
plot(c(1,iter_num), c(0,10),type = "n", xlab = "No. of Iterations", ylab = "Time (s)")
lines(1:iter_num, time_con[,3], col = 3)
lines(1:iter_num, time_con[,4], col = 4)
lines(1:iter_num, time_con[,5], col = 5)
lines(1:iter_num, time_con[,6], col = 6)
lines(1:iter_num, time_con[,7], col = 7)
abline(v = iter_infor[3], lty = 2, col = 2)
abline(v = sum(iter_infor[3:4]), lty = 2, col = 2)
abline(v = sum(iter_infor[3:5]), lty = 2, col = 2)
```

## Check the convergence by traceplots
Here, we draw the traceplot to check the convergence in paramter estimation.
```{r convergence, eval = FALSE}
## Take a look at the convergence
Traceplot <- function(par, subset = NULL, range = NULL, 
                      ...){
  N_iter <- nrow(par)
  Dim <- ncol(par)
  if(!is.null(subset)){
    par <- par[,subset]
  }
  
  # determine the range of the plot
  if(is.null(range)){
    for(i in 1:N_iter){
      range_i <- range(par[i,], na.rm = TRUE)
      range <- range(c(range,range_i), na.rm = TRUE)
    }
  }
  
  p <- plot(c(1,N_iter), range, type = "n", 
            xlab = "IterNum", ...)
  for(g in 1:Dim){
    p <- lines(par[,g],col = g)
  }
  return(p)
}

iter_dir <- paste0("K",K_opt,"_r",r_opt,"/MCESM_iter_K",K_opt,"/")

mini_batch <- 1000
sub_trace <- paste("Traceplot of minibatch size equal to",mini_batch) 

alpha_post <- read.big.matrix(paste0(iter_dir,"alpha_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_alpha_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(alpha_post, ylab = expression(alpha[g]), 
          main = sub_trace)
dev.off()

beta_post <- read.big.matrix(paste0(iter_dir,"beta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_beta_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(beta_post, ylab = expression(beta[gk]), 
          main = sub_trace)
dev.off()

eta_post <- read.big.matrix(paste0(iter_dir,"eta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_eta_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(eta_post, ylab = expression(eta[tgk]), 
          main = sub_trace)
dev.off()

nu_post <- read.big.matrix(paste0(iter_dir,"nu_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_nu_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(nu_post, ylab = expression(nu[bg]),
          main = sub_trace)
dev.off()

delta_post <- read.big.matrix(paste0(iter_dir,"delta_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_delta_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(delta_post, ylab = expression(delta[btgi]), 
          main = sub_trace)
dev.off()

phi_post <- read.big.matrix(paste0(iter_dir,"phi_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_phi_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(phi_post, ylab = expression(phi[bg]), 
          main = sub_trace)
dev.off()

gamma_post <- read.big.matrix(paste0(iter_dir,"gamma_iter.txt"), type = "double", sep = " ")
jpeg(filename = paste0("Images/Traceplot_gamma_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
Traceplot(gamma_post, ylab = expression(gamma[b]), 
          main = sub_trace)
dev.off()

# Traceplot of ARI
w_post <- read.big.matrix(paste0(iter_dir,"w_iter.txt"), type = "double", sep = " ")
record_num <- nrow(w_post)
ARI_post <- rep(NA, record_num)

for(i in 1:record_num){
  ARI_post[i] <- adjustedRandIndex(w_post[i,], metadata$CellType)
}

jpeg(filename = paste0("Images/Traceplot_ARI_",proj,"_v",ver,"_K",K_opt,".jpg"), width = 800, height = 600)
plot(1:record_num * 5, ARI_post, type = "l", xlab = "No. of Iterations", ylab = "ARI")
abline(v = iter_infor[3], lty = 2, col = 2)
abline(v = sum(iter_infor[3:4]), lty = 2, col = 2)
abline(v = sum(iter_infor[3:5]), lty = 2, col = 2)

xaxis = c(iter_infor[3]/2, iter_infor[3] + iter_infor[4]/2, sum(iter_infor[3:4]) + iter_infor[5]/2, sum(iter_infor[3:5]) + iter_infor[6]/2)
text(xaxis, 0.5, labels = paste("Stage",1:4))
dev.off()
```

## Load the estimated parameter values
First, we load the posterior estimators of parameters:
```{r est}
# logistic parameters 
gamma_est <- read.table(paste0(dir_inference,"gamma_est.txt"))

# load cell type labels
w_est <- read.table(paste0(dir_inference,"w_est.txt"))
w_est <- unlist(w_est)
table(w_est, metadata$CellType)

# load alpha_est
alpha_est <- read.table(paste0(dir_inference,"alpha_est.txt"))
alpha_est <- unlist(alpha_est)

# load beta_est
beta_est <- read.table(paste0(dir_inference,"beta_est.txt"))
beta_est <- matrix(unlist(beta_est),G,K_opt)
logmu_est<-beta_est+alpha_est

# load eta_est
eta_est <- read.table(paste0(dir_inference,"eta_est.txt"))
eta_est <- matrix(unlist(eta_est),G,K_opt * Num_Treatment)

# load nu_est #
nu_est <- read.table(paste0(dir_inference,"nu_est.txt"))
nu_est <- matrix(unlist(nu_est),G,B)

# load delta_est
delta_est <- read.table(paste0(dir_inference,"delta_est.txt"))
delta_est <- unlist(delta_est)

# load phi_est
phi_est <- read.table(paste0(dir_inference,"phi_est.txt"))
phi_est <- matrix(unlist(phi_est),G,B)

# load pi_est
pi_est <- read.table(paste0(dir_inference,"pi_est.txt"))
pi_est <- matrix(unlist(pi_est),S,K_opt)

# load p and tau0
ptau1 <- unlist(read.table(paste0(dir_inference,"ptau1_est.txt")))
tau0 <- 0.1
tau1_est <- ptau1[1]
pbeta_est <- ptau1[2]
peta_est <- ptau1[3]
```

Then, we adjust for the order of cell types such that the contingency table of the estimated cell type labels and the true labels concentrates in the diagonal line.
```{r cluster}
annotated_names <- c("Alpha", "Beta", "Delta", "Gamma", "Acinar", "Ductal", "other")
metadata$CellType <- factor(metadata$CellType, levels = annotated_names)
table_celltype <- table(w_est, metadata$CellType)
est_switch <- c(1,2,6,5,4,3)
table_celltype <- table_celltype[est_switch,]
xtable(table_celltype)

celltype_name <- c("Alpha", "Beta", "Delta&Gamma", "Acinar", "Ductal", "Others")
DIFseq_labels <- w_est
for(i in 1:K_opt){
  DIFseq_labels[DIFseq_labels == est_switch[i]] <- celltype_name[i]
}
DIFseq_labels <- factor(DIFseq_labels, levels = celltype_name)

ARI_DIFseq <- adjustedRandIndex(w_est, metadata$CellType)
```

<!-- ## Draw the heatmap of the estimated parameter values -->

<!-- Auxiliary function for Heatmap -->
<!-- ```{r heatmap} -->
<!-- scale01 <- function(x, low = min(x), high = max(x)) { -->
<!--   x <- (x - low)/(high - low) -->
<!--   x -->
<!-- } -->

<!-- draw_keys <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL){ -->
<!--   if(is.null(color_key) & is.null(break_effects)){ -->
<!--     colorsChoice <- colorRampPalette(c("#F2F2F2","#060606")) -->
<!--     color_key <- colorsChoice(10) -->
<!--     len_breaks <- length(color_key) + 1 -->
<!--     break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks) -->
<!--   }else if(is.null(color_key)){ -->
<!--     colorsChoice <- colorRampPalette(c("#F2F2F2","#060606")) -->
<!--     color_key <- colorsChoice(length(break_effects) - 1) -->
<!--   }else if(is.null(break_effects)){ -->
<!--     len_breaks <- length(color_key) + 1 -->
<!--     break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks) -->
<!--   } -->

<!--   z <- seq(min(break_effects), max(break_effects), length = length(color_key)) -->
<!--   image(z = matrix(z, ncol = 1), col = color_key, breaks = break_effects, xaxt = "n", yaxt = "n") -->
<!--   lv <- pretty(break_effects) -->
<!--   xv <- scale01(as.numeric(lv), min(break_effects), max(break_effects)) -->
<!--   axis(1, at = xv, labels = lv, cex.axis = 2.5) -->
<!--   mtext(side = 1, "Value", line = 3.5, cex = 3) -->
<!--   title(main = "Color Key", cex.main = 3) -->

<!-- } -->

<!-- heatmap_effects <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL){ -->

<!--   if(is.null(color_key) & is.null(break_effects)){ -->
<!--     colorsChoice <- colorRampPalette(c("#F2F2F2","#060606")) -->
<!--     color_key <- colorsChoice(10) -->
<!--     len_breaks <- length(color_key) + 1 -->
<!--     break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks) -->
<!--   }else if(is.null(color_key)){ -->
<!--     colorsChoice <- colorRampPalette(c("#F2F2F2","#060606")) -->
<!--     color_key <- colorsChoice(length(break_effects) - 1) -->
<!--   }else if(is.null(break_effects)){ -->
<!--     len_breaks <- length(color_key) + 1 -->
<!--     break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks) -->
<!--   } -->

<!--   out_fig <- heatmap.3(effects_matrix, -->
<!--                        dendrogram = "none",#with cluster tree -->
<!--                        Rowv = FALSE, Colv = FALSE, -->
<!--                        labRow = FALSE, labCol = FALSE, -->
<!--                        ColSideColors = color_bar, -->
<!--                        lmat=rbind(c(5,4),c(0,1), c(3,2)),#1=heatmap, 2=row dendogram, 3=col dendogram, 4= key -->
<!--                        lhei=c(0.3,0.4,3.6), -->
<!--                        lwid = c(0.3,3), -->
<!--                        col=color_key, breaks = break_effects, key = FALSE) -->

<!--   return(out_fig) -->

<!-- } -->

<!-- ``` -->

<!-- Heatmap for the log-scale mean expression levels---$\alpha_{g} + \beta_{gk}$ -->
<!-- ```{r heat_mu, error = TRUE} -->
<!-- logmu_est <- alpha_est + beta_est[, est_switch] -->

<!-- break_mu <- seq(-0.3,4.1, length.out = 8) -->
<!-- color_by_celltype<-c("#F88A7E", "#FFD87D", "#ABD978", "#8097D3", "#9C7ACE") -->

<!-- jpeg(paste0("Images/heatmap_logmu_est_v",ver,"_K",K_opt,"_r",r_opt,".jpg"), width = 480, height = 960, quality = 100) -->
<!-- heat_logmu <- heatmap_effects(logmu_est, color_by_celltype, break_effects = break_mu) -->
<!-- dev.off() -->
<!-- ``` -->

<!-- Heatmap for the log-scale mean expression levels with treatment effects---$\alpha_{g} + \beta_{gk} + \eta_{tgk}$ -->
<!-- ```{r heat_eta, error = TRUE} -->
<!-- color_by_treatment<-c("#EB4334","#FBBD06","#35AA53") -->
<!-- color_bar <- cbind(rep(color_by_celltype,each = Num_Treatment), rep(color_by_treatment,K_opt)) -->

<!-- logmu_est_treat <- matrix(NA, G, Num_Treatment * K) -->
<!-- for(k in 1:K){ -->
<!--   for(t in 1:Num_Treatment){ -->
<!--     logmu_est_treat[,(k-1) * Num_Treatment + t] <- alpha_est + beta_est[,est_switch[k]] + eta_est[, K * (t-1) + est_switch[k]] -->
<!--   } -->
<!-- } -->

<!-- break_mean <- seq(-0.3,5.5, length.out = 12) -->
<!-- # break_mean <- seq(min(logmu_est_treat), max(logmu_est_treat), length.out = 8) -->
<!-- jpeg(paste0("Images/heatmap_logmu_diff_treatment_est_v",ver,"_r",r_opt,".jpg"), -->
<!--      width = 480, height = 960) -->
<!-- heat_logmu <- heatmap_effects(logmu_est_treat, break_effects = break_mean, color_bar) -->
<!-- dev.off() -->

<!-- ``` -->


<!-- Heatmap for treatment effects $\eta_{tgk}$ -->
<!-- ```{r eta, error = TRUE} -->
<!-- eta.out <- eta_est -->
<!-- for(k in 1:K){ -->
<!--   for(t in 1:Num_Treatment){ -->
<!--     eta.out[,(k-1) * Num_Treatment + t] <- eta_est[,K * (t-1) + est_switch[k]] -->
<!--   } -->
<!-- } -->

<!-- break_eta <- seq(min(eta.syn), max(eta.syn), length.out = 8) -->
<!-- colorsChoice <- colorRampPalette(c("red","#F2F2F2","blue")) -->
<!-- color_key <- colorsChoice(7) -->
<!-- jpeg(paste0("Images/heatmap_eta_est_v",ver,"_r",r_opt,".jpg"), -->
<!--      width = 480, height = 960) -->
<!-- heat_eta <- heatmap_effects(eta.out, color_bar,  -->
<!--                             break_effects = break_eta, color_key = color_key) -->
<!-- dev.off() -->
<!-- ``` -->

<!-- Heatmap for batch effects $\nu_{bg}$ -->
<!-- ```{r nu, error = TRUE} -->
<!-- color_by_batch<-viridis(6) -->
<!-- colorsChoice <- colorRampPalette(c("red","#F2F2F2","blue")) -->
<!-- color_key <- colorsChoice(7) -->

<!-- # break_nu <- seq(min(nu.syn), max(nu.syn), length.out = 8) -->
<!-- break_nu <- seq(-3.2,3.2, length.out = 8) -->

<!-- jpeg(paste0("Images/heatmap_nu_est_v",ver,"_r",r_opt,".jpg"),width = 480, height = 960, quality = 100) -->
<!-- heat_eta <- heatmap_effects(nu_est, color_by_batch, break_effects = break_nu, color_key = color_key) -->
<!-- dev.off() -->
<!-- ``` -->

<!-- Scatter plot for cell size factors $\delta_{sig}$ -->
<!-- ```{r size_factor, error = TRUE} -->
<!-- jpeg(paste0("Images/scatter_plot_delta_est_v",ver,"_r",r_opt,".jpg"),width = 540, height = 1080, quality = 100) -->
<!-- old_par <- par(mar = c(5,5,4,2) + 0.1) -->
<!-- plot(delta.syn,delta_est, type = "p",xlab = expression(paste("Ture ",delta)), ylab = expression(paste("Estimated ",delta)), cex = 3, cex.lab = 3, cex.axis= 2) -->
<!-- abline(a = 0, b = 1, lty = 2, col=2) -->
<!-- par(old_par) -->
<!-- dev.off() -->
<!-- ``` -->

## Clustering results

### Barplot for ARI comparison
```{r, ARI comparison}
# Barplot of ARI
ARI_comparison <- c(0.814, 0.653, 0.629, 0.608, 0.542, 0.527, 0.380, 0.287, 0.279, 0.282) 

Name_methods <- c("DIFseq", "Seurat_v4", "Milo", "BUSseq", "MNN", "ZINB-WaVE", "scVI", "Seurat_v3", "LIGER", "Scanorama")

df_ARI <- data.frame(Method = factor(Name_methods, levels = Name_methods),
                     ARI = ARI_comparison)

pdf(file = paste0("Images/ARI_comparison_",proj,"_v",ver,".pdf"), width = 12, height = 6)
p <- ggplot(data = df_ARI, mapping = aes(x = Method, fill = Method, 
                                         y = ARI_comparison)) + 
  geom_col(#color = "#939393", 
           position=position_dodge()) +
  # scale_fill_manual(values=color_by_treatment[2:3]) +
  scale_x_discrete(limits=rev) +
  coord_flip() +
  labs(x = "Method", y = "ARI"#,fill = "Method"
       ) +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        legend.position="none")
p
dev.off()
                 
```

### Draw cell type proprotions of each sample
To show the cell type proportion changes in each individual, we draw the individual-specific cell type proportions $\pi_{sk}$ in a bar plot.

```{r}
pi_ordered <- pi_est[,est_switch]
colnames(pi_ordered) <- celltype_name
rownames(pi_ordered) <- sample_id

sample_id <- unique(metadata$Donor)

df_prop <- data.frame(Sample=factor(rep(sample_id, K_opt),levels = sample_id),
  CellType = factor(rep(celltype_name, each = S), levels = celltype_name),
  Prop = as.vector(pi_ordered))

color_by_celltype <- rainbow(K_opt)

pdf(file = paste0("Images/CellTypeProportion_",proj,"_v",ver,".pdf"), width = 12, height = 8)
p <- ggplot(data = df_prop, mapping = aes(x = Sample, fill = CellType, y = Prop)) + 
  geom_col(width = 1, color = "#939393") +
  scale_fill_manual(values=color_by_celltype) +
  labs(x = "Sample", y = "Cell Type Proportion",colour = "Cell Type") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), #change legend title font size
        legend.text = element_text(size=20),
        panel.grid = element_blank(),
        panel.background =element_blank(),
        panel.border = element_blank()) +
  guides(fill=guide_legend(title="Cell Type")) +
  ylab("Cell-type proportions")
p
dev.off()

#########################################
# Draw color annotation bar by pheatmap #
#########################################
# Define the column names and row names
pi_pheat <- t(pi_ordered)
colnames(pi_pheat) <- sample_id

annotation_samples <- data.frame(
  Treatment = factor(metadata$Disease[!duplicated(metadata$Donor)]),
  Batch = factor(metadata$Study[!duplicated(metadata$Donor)]))
rownames(annotation_samples) <- sample_id

# Specify the color of the annotation bar
color_by_treatment <- c("#ffffb3","#fbb4ae")
color_by_batch <- viridis(4)

names(color_by_treatment) <- c("ND", "T2D")
names(color_by_batch) <- unique(metadata$Study)

sample_colors = list(Treatment = color_by_treatment,
                     Batch = color_by_batch)

pdf(paste0("Images/heatmap_celltype_proportion_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 12, height = 8)
pheatmap(pi_pheat, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdYlBu")))(100),
         breaks = seq(0,1,length.out = 100),
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         annotation_col = annotation_samples,
         annotation_colors = sample_colors,
         show_colnames = FALSE,
          scale = "none") 
dev.off()
```

## Differential abundance
Load the MC samples of cell type labels and switch labels to be consistent with true cell type labels
```{r load_w}
w_MC <- read.table(paste0(dir_inference,"w_MC.txt"))

names(est_switch) <- 1:K_opt
label_switch <- as.numeric(names(sort(est_switch)))
w_MC <- matrix(label_switch[unlist(w_MC)], ncol = 10)

```



Louis estimator
```{r Louis}
# function to obtain the Louis estimators of cell type proportion Pi_{sk}
Louis_variance_MCESM <- function(cell_proportion, cell_labels_MC){
  
  if(is.list(cell_proportion)){
    cell_proportion <- unlist(cell_proportion)
  }
  
  n_rep <- ncol(cell_labels_MC)
  K <- length(cell_proportion)
  Km1 <- length(cell_proportion) - 1
  
  sum_w <- matrix(NA, K, n_rep)
  for(r in 1:n_rep){
    for(k in 1:K){
      sum_w[k,r] <- sum(cell_labels_MC[,r]==k)
    }
  }
  
  # Add 0.01 for singular values
  sum_w <- sum_w + 0.01
  
  #print(sum_w)
  
  first_der <- rep(0, Km1)
  first_der_cross <- matrix(0, Km1, Km1)
  second_der <- matrix(0, Km1, Km1)
  
  for(r in 1:n_rep){
    temp_first <- sum_w[1:(K - 1),r]/cell_proportion[1:(K-1)] - sum_w[K]/cell_proportion[K]
    first_der <- first_der + temp_first
    first_der_cross <- first_der_cross + temp_first %*% t(temp_first)
    second_der <- second_der - 
      diag(sum_w[1:(K - 1),r]/(cell_proportion[1:(K-1)])^2) - 
      sum_w[K,r]/(cell_proportion[K])^2
  }
  
  first_der <- first_der/n_rep
  first_der_cross <- first_der_cross/n_rep
  second_der <- second_der/n_rep
  
  obs_variance <- -second_der + first_der_cross - first_der %*% t(first_der)
  obs_variance <- solve(obs_variance)
  
  return(obs_variance)
}
```

```{r DA}
Diff.Abundance <- function(.pi, w, meta, ref = ncol(.pi), dim = c("Treat", "Batch", "Pair"), subset = NULL){
  
  .K <- ncol(.pi)
  .S <- nrow(.pi)
  s_infor <- meta$sample
  .cname <- colnames(.pi)
  .cname <- .cname[-ref]
  # browser()
  
  if(dim == "Treat"){
      # get the indices of each cell and the number of treatments
      d_infor <- factor(meta$treatment)
    }else if(dim == "Batch"){
      d_infor <- factor(meta$batch)
    }else if(dim == "Pair"){
      d_infor <- factor(meta$pair)
    }
    
    if(is.null(subset)){

      .dname <- levels(d_infor)
      .d <- length(.dname)
      .dsub <- 1:.d

    }else{

      .dsub <- subset
      .d <- length(subset)
      .dname <- levels(d_infor)[subset]

    }

    # Sample_set stores samples belonging to each treatment
    Sample_set <- list()
    for (j in 1:.d) {
      Sample_set[[j]] <- unique(s_infor[as.numeric(d_infor) == .dsub[j]])
    }

    res <- matrix(NA, .d * (.d - 1) / 2, 2 * .K)
    row_names <- NULL
    
    # compute Louis' estimator
    lvar <- array(NA, dim = c(.S, .K - 1, .K - 1))
    
    # put the reference to the last column
    if(ref != .K){
      .pi <- cbind(.pi[,-ref] , .pi[,ref])
      pos_ref <- which(w == ref)
      pos_lat <- which(w > ref)
      w[pos_ref] <- .K
      w[pos_lat] <- w[pos_lat] - 1
    }
    
    for(s in 1:.S){
      cell_index <- which(s_infor==s)
      lvar[s,,] <- Louis_variance_MCESM(.pi[s,],w[cell_index,]) 
    }
    
    index <- 1
    for (j1 in 1:(.d - 1)) {
      for (j2 in (j1+1):.d) {

        set1 <- Sample_set[[j1]]
        set2 <- Sample_set[[j2]]

        ns1 <- length(set1)
        ns2 <- length(set2)

        # Difference in proportion
        if(ns1 > 1){
          pi_mean_1 <- apply(.pi[set1, ], 2, mean)
        }else{
          pi_mean_1 <- .pi[set1, ]
        }
        
        if(ns2 > 1){
          pi_mean_2 <- apply(.pi[set2, ], 2, mean)
        }else{
          pi_mean_2 <- .pi[set2, ]
        }
          
        pi_dif <- pi_mean_1 - pi_mean_2

        # Compute within-group covariance
        Var_within <- matrix(0, .K - 1, .K - 1)
        for (s in set1) {
          Var_within <- Var_within + lvar[s, ,] / ns1 ^ 2
        }

        for (s in set2) {
          Var_within <- Var_within + lvar[s, ,] / ns2 ^ 2
        }

        # Compute between-group covariance
        Var_est <- Var_within
        
        if(ns1 > 1){
          Var_est <- Var_est + cov(.pi[set1, 1:(.K - 1)])/ns1
        }
        
        if(ns2 > 1){
          Var_est <- Var_est + cov(.pi[set2, 1:(.K - 1)])/ns2
        }

        # test statistics
        stat_celltype <- pi_dif[1:(.K - 1)] / sqrt(diag(Var_est))
        stat_overall <- t(pi_dif[1:(.K - 1)]) %*% solve(Var_est) %*% pi_dif[1:(.K - 1)]

        # pval
        p_celltype <- 2 * (1 - pnorm(abs(stat_celltype)))
        p_overall <- pchisq(stat_overall, df = .K - 1, lower.tail = FALSE)

        # # adjust by BH
        # p_adj <- p.adjust(p_celltype, method = "BH")

        res[index, 2 * 1:.K - 1] <- c(stat_celltype, stat_overall)
        # res[index, 2 * 1:.K] <-  c(p_adj, p_overall)
        res[index, 2 * 1:.K] <-  c(p_celltype, p_overall)
        
        row_names <- c(row_names, paste(.dname[j1], "vs", .dname[j2]))

        index <- index + 1
      }
    }
    
  
  rownames(res) <- row_names
  colnames(res) <- paste(rep(c(.cname,"Overall"),each = 2),rep(c("stat", "pval"),.K),sep = ":")
  
  return(res)
}

meta_da <- data.frame(batch = btp_ind[,1], treatment = btp_ind[,2], pair = btp_ind[,3], sample = btp_ind[,4])

# Diff.Abundance(pi_ordered, w_MC, meta = metadata, ref = 1, dim = "Treat", subset = c(1,2), alg = "MCESM")

# Batch 3 in treatment 1 and 2
DA_GSE86473 <- Diff.Abundance(pi_ordered[,1:3], w_MC, meta = meta_da, ref = 3, dim = "Pair", subset = c(3,4))

xtable(DA_GSE86473, digits = 3)

# Exclude the 40th donor HP1526901T2D 
meta_da[meta_da[,4] == 40,3] <- 100

# Batch 4 in treatment 1, 2
DA_EMTAB5061 <- Diff.Abundance(pi_ordered, w_MC, meta = meta_da, ref = K_opt, dim = "Pair", subset = c(5,6))
xtable(DA_EMTAB5061, digits = 3)

```
## Differential expression

### Intrinsic gene identification 
```{r intrinsic_genes}
.fdrDEindicator <- function(xi, kappa){

  ind_intr <- xi <= kappa
  fdr <- sum(xi[ind_intr])/sum(ind_intr)

  return(fdr)
}

# Calculate the DE posterior probability threshold
.postprob_DE_thr_fun <- function(xi, fdr_threshold=0.05){

  kappa_fdr_matr <- NULL
  kappa_set <- sort(unique(xi))
  
  kappa_ind <- which(kappa_set < 0.5 & kappa_set > fdr_threshold)
  
  for(i in kappa_ind){
    
    kappa <- kappa_set[i]
    fdr <- .fdrDEindicator(xi, kappa=kappa)
    
    if(fdr > fdr_threshold){
      break
    }
  }
  
  kappa <- kappa_set[i-1]
  return(kappa)
}

# Estimate intrinsic gene indicators
.estimate_IG_indicators <- function(xi, postprob_DE_threshold = 0.5){

  EstL <- xi
  EstL[xi >= postprob_DE_threshold] <- 0
  EstL[xi <= postprob_DE_threshold] <- 1
  # message("The output format is a matrix.\n")
  # message(paste0("Each row represents a gene, and each column",
  #               " corresponds to a cell type from 2 to K\n"))
  return(EstL)
}

# Intrinsic gene index
.IG_index <- function(EstIGindicators){
  ind <- which(rowSums(EstIGindicators) > 0)
  message(c(length(ind), " intrinsic genes are found.\n"))
  message("The output format is a vector implying the intrinsic gene",
          " indices.\n")
  return(ind)
}

# Load log(Pr(L = 0)) and log(Pr(J = 0))
PrL_est <- matrix(unlist(read.table(paste0(dir_inference,"PrL_est.txt"))), nrow = G)
PrJ_est <- matrix(unlist(read.table(paste0(dir_inference,"PrJ_est.txt"))), nrow = G)

PrL_est <- exp(PrL_est)
PrJ_est <- exp(PrJ_est)

colnames(PrL_est) <- paste0("K",1:K_opt)
colnames(PrJ_est) <- paste0("T",rep(1:Num_Treatment, each = K_opt),"K",rep(1:K_opt, Num_Treatment))

pval_col <- cbind(PrL_est[,-1], PrJ_est[, K_opt + 1:((Num_Treatment - 1) * K_opt)])

xi_thres <- .postprob_DE_thr_fun(pval_col, 0.01)
DE_est <- .estimate_IG_indicators(pval_col, xi_thres)

D_est <- apply(DE_est[,1:(K_opt-1)], 1, sum) > 0
num_intri <- sum(D_est)

E_est <- apply(DE_est[,K_opt - 1 + 1:((Num_Treatment - 1) * K_opt)], 1, sum) > 0
num_DE <- sum(E_est)

################################################
# consider the expression proportions of genes #
################################################
thres_adj <- 0.3
## intrinsic genes
L_est <- DE_est[,1:(K_opt - 1)]
L_adj <- matrix(0, G, K_opt - 1)

expr_prop <- array(NA, dim = c(G, K_opt, 2))

for(k in 2:K_opt){
  celltype_k <- which(w_est == k)
  for(g in which(L_est[,k-1] == 1)){
    
    yg <- y_obs[g, ]
    
    ygk <- yg[celltype_k]
    ygnk <- yg[-celltype_k]
    
    expr_prop[g,k,1] <- sum(ygk > 0)/length(ygk)
    expr_prop[g,k,2] <- sum(ygnk > 0)/length(ygnk)
    
    if(expr_prop[g,k,1] > thres_adj & expr_prop[g,k,2] > thres_adj){
      L_adj[g, k - 1] <- 1 
    }
  }
  
  jpeg(filename = paste0("../Images/BDplot_",proj,"_v",ver,"_Type",k,".jpg"), width = 800, height = 600)
  col_nodes <- rep("black", G)
  col_nodes[L_est[,k-1] == 1] <- "blue"
  col_nodes[L_adj[,k-1] == 1] <- "red"
  plot(alpha_est, beta_est[,k], xlab = "Baseline expression levels alpha", ylab ="cell type effects beta", col = col_nodes)
  dev.off()
}

D_adj <- apply(L_adj, 1, sum) > 0
sum(D_adj)

### output intrinsic genes for pathway analysis
Intrinsic_genes <- gene_list[D_adj==1]
write.table(Intrinsic_genes, file = paste0("Intrinsic_gene_",proj,"_v",ver,".txt"), row.names = FALSE, col.names = FALSE, quote = FALSE)

# # Select the top intrinsic genes
# rownames(PrL_est) <- gene_list
# PrL_ordered <- PrL_est[, est_switch]
# beta_ordered <- beta_est[, est_switch]
# 
# beta_mean <- apply(beta_ordered, 1, mean)
# names(beta_mean) <- gene_list
# Top2_genes <- names(head(sort(beta_mean),2))
# 
# for(k in 2:K_opt){
#   Top2_genes <- c(Top2_genes, names(head(sort(PrL_ordered[beta_ordered[,k] > 1 & D_adj > 0,k], decreasing = TRUE),2)))
# }
# 
# 
# w_factor <- factor(w_est, levels = est_switch, labels = colnames(pi_ordered))
# Corrected_DIFseq$DIFseq_cluster <- w_factor
# DotPlot(Corrected_DIFseq, features = Top2_genes, cols = c("blue", "red"), dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis()

```

```{r celltype_DE}
J_est <- DE_est[,K_opt - 1 + 1:((Num_Treatment - 1) * K_opt)]
J_adj <- matrix(0, G, (Num_Treatment - 1) * K_opt)

expr_prop_treatment <- array(NA, dim = c(G, Num_Treatment,K_opt, 2))

for(t in 2:Num_Treatment){
  for(k in 1:K_opt){
    celltype_t <- which(w_est == k & btp_ind[,2] == t)
    celltype_other <- which(w_est == k & btp_ind[,2] != t)
    for(g in which(J_est[,k + (t-2) * K_opt] == 1)){
      
      yg <- y_obs[g, ]
      
      ygt <- yg[celltype_t]
      ygnt <- yg[celltype_other]
      
      expr_prop_treatment[g,t,k,1] <- sum(ygt > 0)/length(ygt)
      expr_prop_treatment[g,t,k,2] <- sum(ygnt > 0)/length(ygnt)
      print(expr_prop_treatment[g,t,k,])
      
      if(expr_prop_treatment[g,t,k,1] > thres_adj & expr_prop_treatment[g,t,k,2] > thres_adj){
        J_adj[g, k + (t-2) * K_opt] <- 1 
      }
    }
    
    jpeg(filename = paste0("../Images/BDplot_",proj,"_v",ver,"_Treatment",t,"_Type",k,".jpg"), width = 800, height = 600)
    col_nodes <- rep("black", G)
    col_nodes[J_est[,k + (t-2) * K_opt] == 1] <- "blue"
    col_nodes[J_adj[,k + (t-2) * K_opt] == 1] <- "red"
    plot(alpha_est + beta_est[,k], eta_est[,k + (t-1) * K_opt], 
         xlab = paste0("Expression levels of cell type ",k), 
         ylab =paste0("Effects of treatment ",t), col = col_nodes)
    dev.off()
  }
}

E_adj <- apply(J_adj, 1, sum) > 0
sum(E_adj)

# # Differentially expressed genes across treatments
E_combinded <- J_adj[,1:K_opt]
E_ordered <- E_combinded[, est_switch]
colnames(E_ordered) <- celltype_name
intri_acorss_treat <- apply(E_ordered,2,sum)

celltype_names <- colnames(pi_ordered)

#gene_list <- unlist(gene_list)
for(k in 1:K_opt){
  Intrinsic_genes <- gene_list[E_ordered[,k]==1]
  write.table(Intrinsic_genes, file = paste0("Intrinsic_gene_",proj,"_v",ver,"_",celltype_names[k],".txt"),
              row.names = FALSE, col.names = FALSE, quote = FALSE)
}

# #Beta_DE_genes <- gene_list[E_ordered[,2]==1]
# FeaturePlot(Corrected_DIFseq, features = c("GCG","INS"), split.by = "Disease", max.cutoff = 3,
#     cols = c("grey", "red"))
# 
# 
# Corrected_DIFseq$DIFseq_cluster <- DIFseq_labels
#   
# plots <- VlnPlot(Corrected_DIFseq, features = c("GCG","INS","SST", "PPY", "KRT19", "PRSS1"), split.by = "Disease", group.by = "DIFseq_cluster", pt.size = 0, combine = FALSE, log = TRUE)
# wrap_plots(plots = plots, ncol = 3)
# 
# 
# marker_genes <- c("GCG", "INS", "PPY", "SST", "PRSS1", "KRT19")
# DotPlot(Corrected_DIFseq, features = marker_genes, cols = c("blue", "red"), 
#         dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis()

```

Output the DAVID table in latex format
```{r, eval = FALSE}
pathway_intri <- read.table(paste0("DAVID_intrinsic_",proj,"_v",ver,".txt"),header = TRUE, sep = "\t")
xtable(pathway_intri[,c(2,5,6)],digits = 3)
```

```{r KEGG_treat, eval = FALSE}

pathway_cond <- NULL
ct_label <- colnames(pi_ordered)

for(k in 1:(K_opt-1)){
  ct <- ct_label[k]
  pathway_cur <- read.table(paste0("DAVID_",ct,"_",proj,"_v",ver,".txt"),header = TRUE, sep = "\t")
  pathway_cur <- pathway_cur[,c(2,5,6)]
  pathway_cur <- cbind(ct,pathway_cur)
  pathway_cond <- rbind(pathway_cond, pathway_cur)
}
xtable(pathway_cond,digits = 3)
```

### Draw dot plot for enriched pathways
```{r KEGG_treat, eval = FALSE}
pathway_cond <- NULL

for(k in 1:K_opt){
  ct <- celltype_name[k]
  pathway_cur <- read.table(paste0("DAVID_",ct,"_",proj,"_v",ver,".txt"),header = TRUE, sep = "\t")
  if(nrow(pathway_cur) > 0){
    pathway_cur <- pathway_cur[,c(2,5,6)]
    pathway_cur <- cbind(ct,pathway_cur)
    
    pathway_cur$Rank <- 1:nrow(pathway_cur)
    
    pathway_cond <- rbind(pathway_cond, pathway_cur)
    
  }
}

# # Keep interesting pathways
# freq_pathways <- table(pathway_cond$Term)
# path_interest <- freq_pathways[freq_pathways > 4]
# path_interest <- sort(path_interest, decreasing = TRUE)
# path_names <- names(path_interest)
# 
# # reorder the interesting list of pathways
# path_names[1:2] <- path_names[2:1] # Move COVID-19 pathway to the first
# path_names[3:4] <- path_names[4:3] # Move Influenza in front of Measles
# path_names[5:10] <- path_names[c(6,7,8,5,9,10)]
# path_names[11:27] <- path_names[c(20,23,11:19,21,22,24:27)]

# pathway_cond <- pathway_cond[pathway_cond$Term %in% path_names,]
pathway_cond$log_pval <- -log10(pathway_cond$PValue)

pathway_cond$ct <- factor(pathway_cond$ct, levels = celltype_name)
pathway_cond$Term <- factor(pathway_cond$Term)

pdf(paste0("Images/dotplot_enriched_pathway_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 12, height = 6)
ggplot(pathway_cond, aes(x = ct, y = Term)) + 
  geom_point(aes(color = log_pval, size = 1/Rank), alpha = 0.5) +
  scale_y_discrete(limits=rev) +
  scale_fill_gradient(low = "#132B43", high = "#56B1F7") + 
  labs(x = "Cell Type", y = "Pathway",color = "-log10(pval)", size = "1/Rank") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), 
        #change legend title font size
        legend.text = element_text(size=20),
        # panel.grid = element_blank(),
        # panel.background =element_blank(),
        # panel.border = element_blank()
        )
dev.off()
```

### Draw the heatmap of treatment effects by `heatmap3.R` and `pheatmap`

Auxiliary function to draw heatmaps by `heatmap3.R`
```{r}
source("../../heatmap3.R")
scale01 <- function(x, low = min(x), high = max(x)) {
  x <- (x - low)/(high - low)
  x
}

draw_keys <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL){
  if(is.null(color_key) & is.null(break_effects)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(10)
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }else if(is.null(color_key)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(length(break_effects) - 1)
  }else if(is.null(break_effects)){
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }

  z <- seq(min(break_effects), max(break_effects), length = length(color_key))
  image(z = matrix(z, ncol = 1), col = color_key, breaks = break_effects, xaxt = "n", yaxt = "n")
  lv <- pretty(break_effects)
  xv <- scale01(as.numeric(lv), min(break_effects), max(break_effects))
  axis(1, at = xv, labels = lv, cex.axis = 2.5)
  mtext(side = 1, "Value", line = 3.5, cex = 3)
  title(main = "Color Key", cex.main = 3)

}

heatmap_effects <- function(effects_matrix, color_bar, color_key = NULL, break_effects = NULL, ...){

  if(is.null(color_key) & is.null(break_effects)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(10)
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }else if(is.null(color_key)){
    colorsChoice <- colorRampPalette(c("#F2F2F2","#060606"))
    color_key <- colorsChoice(length(break_effects) - 1)
  }else if(is.null(break_effects)){
    len_breaks <- length(color_key) + 1
    break_effects <- seq(min(effects_matrix), max(effects_matrix), length.out = len_breaks)
  }

  out_fig <- heatmap.3(effects_matrix,
                       dendrogram = "row",#with cluster tree
                       Rowv = TRUE, Colv = FALSE,
                       # labRow = FALSE, labCol = FALSE,
                       ColSideColors = color_bar,
                       lmat=rbind(c(5,4),c(0,1), c(3,2)),#1=heatmap, 2=row dendogram, 3=col dendogram, 4= key
                       lhei=c(0.3,0.4,3.6),
                       lwid = c(0.3,3),
                       col=color_key, breaks = break_effects, key = FALSE, ...)

  return(out_fig)

}
```


```{r, error=TRUE}
eta_ordered <- eta_est
for(t in 2:Num_Treatment){
  eta_ordered[,(t-1) * K_opt + 1:K_opt] <- eta_est[, (t-1) * K_opt + est_switch]
}

eta_organized <- eta_ordered
for(k in 1:K_opt){
  eta_organized[,(k-1) * Num_Treatment + 1:Num_Treatment] <- eta_ordered[,0:(Num_Treatment-1) * K_opt + k]
}

rownames(eta_organized) <- gene_list
treatment_effects_by_celltype <- eta_organized[E_adj,]

####################
# Draw by pheatmap #
####################
# Color bar
cond_id <- paste(
  rep(celltype_name, each = Num_Treatment), 
  rep(1:Num_Treatment, K_opt), 
  sep = "_")

colnames(treatment_effects_by_celltype) <- cond_id

annotation_cond <- data.frame(
  Treatment = factor(rep(c("ND","T2D"), K_opt)),
  CellType = factor(rep(celltype_name, each = Num_Treatment), 
                    levels = celltype_name))

rownames(annotation_cond) <- cond_id

# Specify the color of the annotation bar
# color_by_treatment <- c("#ccebc5","#b3cde3","#fbb4ae")
# color_by_celltype <- rainbow(K_opt)

names(color_by_celltype) <- celltype_name

cond_colors = list(Treatment = color_by_treatment,
                     CellType = color_by_celltype)

# logmu_ordered <- alpha_est + beta_ordered + eta_ordered
pdf(paste0("Images/pheatmap_treatment_effects_by_celltype_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 8, height = 12)
pheatmap(treatment_effects_by_celltype,
         color = colorRampPalette(c("#1D78B2","#F2F2F2","#C4012D"))(101),
         breaks = seq(-4,4,0.08),
         cluster_cols = FALSE,
         annotation_col = annotation_cond,
         annotation_colors = cond_colors,
         show_colnames = FALSE,
         scale = "none") 
dev.off()

#####################
# Draw by heatmap.3 #
#####################
# range
break_combined <- seq(-3,3, length.out = 101)
colorsChoice <- colorRampPalette(c("#1D78B2","#F2F2F2","#C4012D"))
color_key <- colorsChoice(100)

# Color bar
color_bar <- cbind(rep(color_by_treatment,K_opt),
  rep(color_by_celltype, each = Num_Treatment))

pdf(paste0("Images/heatmap_treatment_effects_by_celltype_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 6)
heat_logmu <- heatmap_effects(treatment_effects_by_celltype,
                              color_bar,
                              break_effects = break_combined,
                              labCol = FALSE,
                              color_key = color_key)
dev.off()

jpeg(paste0("Images/colorkey_treatment_effects_by_celltype_v",ver,".jpg"),width = 480, height = 240)
draw_keys(treatment_effects_by_celltype, 
          color_key = color_key,
          break_effects = break_combined)
dev.off()

```

Draw the heatmap of logarithm expression levels by `pheatmap`
```{r}
# Draw the heatmap of mean expression levels in each cell type and each treatment
beta_ordered <- beta_est[,est_switch]
eta_ordered <- eta_est
for(t in 2:Num_Treatment){
  eta_ordered[,(t-1) * K_opt + 1:K_opt] <- eta_est[, (t-1) * K_opt + est_switch]
}

logmu_ordered <- eta_ordered
eta_organzied <- eta_est

for(k in 1:K_opt){
  for(t in 1:Num_Treatment){
    logmu_ordered[,(k-1) * Num_Treatment + t] <- alpha_est + beta_ordered[, k] + eta_ordered[, (t-1) * K_opt + k]
    
    eta_organzied[, (k-1) * Num_Treatment + t] <- eta_ordered[, (t-1) * K_opt + k]
  }
}

celltype_label <- paste0(rep(celltype_name,each = Num_Treatment),"_",rep(c("Healthy","Moderate","Severe"),K_opt))

colnames(logmu_ordered) <- celltype_label
# rownames(logmu_ordered) <- gene_list
rownames(logmu_ordered) <- NULL

# logmu_ordered <- alpha_est + beta_ordered + eta_ordered
pdf(paste0("Images/heatmap_logmu_ordered_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_ordered, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

pdf(paste0("Images/heatmap_logmu_ordered_rowcluster_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_ordered, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2))
dev.off()
```

Draw heatmap for intrinsic genes and cell-type-specific DE genes
```{r}
intrinsic_index <- which(D_adj)
logmu_intri <- logmu_ordered[intrinsic_index,]

intrinsic_genes <- gene_list[intrinsic_index]
# rownames(logmu_intri) <- intrinsic_genes
rownames(logmu_intri) <- NULL
colnames(logmu_intri) <- celltype_label

# Draw heatmap for all intrinsic genes
pdf(paste0("Images/heatmap_logmu_intri_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_intri, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

# Heatmap of cell-type-specific DE genes
rownames(logmu_ordered) <- gene_list
rownames(eta_organzied) <- gene_list
E_ordered <- E_combinded[, est_switch]

for(k in 1:K_opt){
  
DE_index <- which(E_ordered[,k])

logmu_celltype <- logmu_ordered[DE_index,(k-1) * Num_Treatment + 1:Num_Treatment]
colnames(logmu_celltype) <- c("Healthy", "Moderate", "Severe")

pdf(paste0("Images/heatmap_celltype_DE_",celltype_name[k],"_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(logmu_celltype, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-10,10,0.2),
         cluster_cols = FALSE) 
dev.off()

eta_celltype <- eta_organzied[DE_index,(k-1) * Num_Treatment + 1:Num_Treatment]
colnames(eta_celltype) <- c("Healthy", "Moderate", "Severe")

pdf(paste0("Images/heatmap_eta_DE_",celltype_name[k],"_v",ver,"_K",K_opt,"_r",r_opt,".pdf"), width = 6, height = 12)
pheatmap(eta_celltype, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdYlBu")))(101),
         breaks = seq(-5,5,0.1),
         cluster_cols = FALSE) 
dev.off()

}
```


## Correct batch effects and visualize the corrected read counts by UMAP

```{r correct}
adjusted_values <- function(ReadCount, Indicators, .K,
                            .alpha, .beta, .eta, .nu, .delta, .phi, .w){
  CorrectedCount <- ReadCount
  N <- ncol(ReadCount)
  for(i in 1:N){
    
    b <- Indicators[i,1]
    t <- Indicators[i,2]
    w <- .w[i]
    
    # percentile
    px <- pnbinom(ReadCount[,i], size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i]))
    pxminus1 <- pnbinom(ReadCount[,i] - 1, size = .phi[,b], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w] + .nu[,b] + .delta[i]))
    
    # get the aligned percentile
    local_u <- runif(G) * (px - pxminus1) + pxminus1
    local_u <- ifelse(local_u > 0.9999, 0.9999, local_u)
    
    # obtain the quantile
    CorrectedCount[,i] <- qnbinom(local_u, size = .phi[,1], mu = exp(.alpha + .beta[,w] + .eta[,(t-1) * .K + w]))
    
    if(i %% 100 == 0){
      print(paste("Finish the correction of", i, "cells..."))
      
    }
  }
  return(CorrectedCount)
}

x_imputed <- read.table(paste0(dir_inference,"imputed_count.txt"))
colnames(x_imputed) <- metadata$Sample
rownames(x_imputed) <- gene_list

start_time<-Sys.time()
message("Calculate corrected read counts:")
x_corrected <-adjusted_values(x_imputed, btp_ind, K_opt,
                             alpha_est, beta_est, eta_est,nu_est,delta_est,phi_est,w_est)
write.table(x_corrected, file = paste0("K",K_opt,"_r",r_opt,"/Inference_K",K_opt,"/corrected_count.txt"), row.names = FALSE, col.names = FALSE)
end_time<-Sys.time()
running_time<-difftime(end_time, start_time, units = "mins")
message("It takes ",running_time," mins to calculate the corrected data.")

rownames(metadata) <- metadata$Sample
```

### Dot plot of marker genes
```{r}
marker_genes <- c("GCG", "INS", "PPY", "SST", "PRSS1", "KRT19")

# Adjust cell type labels
w_ordered <- label_switch[w_est]

# gene <- "ISG15"

df_marker <- NULL
for(gene in marker_genes){
  log_mean_counts <- rep(NA, K_opt * Num_Treatment)
  expr_prop <- rep(NA, K_opt * Num_Treatment)
  
  corrected_count <- unlist(x_corrected[gene_list == gene, ])
  
  df_count <- data.frame(DIFseq_type = celltype_name[w_ordered],
                         Treatment = metadata$Disease,
                         Count = corrected_count)
  
  df_summary <- df_count %>% 
    group_by(DIFseq_type, Treatment) %>%
    summarise(LogMeanExp = mean(log1p(Count)), 
              ExprProp = mean(Count > 0))

  
  df_summary$Marker <- gene
  
  df_marker <- rbind(df_marker, df_summary)
}

df_marker$DIFseq_type <- factor(df_marker$DIFseq_type, levels = celltype_name)
df_marker$Marker <- factor(df_marker$Marker, levels = marker_genes)

pdf(file = paste0("Images/Dotplot_marker_genes_",proj,"_v",ver,".pdf"), width = 8, height = 12)
ggplot(df_marker, aes(x = DIFseq_type, y = Treatment)) + 
  geom_point(aes(color = LogMeanExp, size = ExprProp), alpha = 0.8) + facet_grid(Marker ~.) + 
  # scale_y_discrete(limits=rev) +
  scale_color_gradient(low = "#F2F2F2", high = "#C4012D") + 
  labs(x = "Cell Type", y = "Treatment",color = "Average Expression", size = "Precent Expressed") +
  theme(axis.text=element_text(size=20), 
        axis.title=element_text(size=24,face="bold"),
        strip.text.y = element_text(size = 20),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        legend.title = element_text(size=20, face = "bold"), 
        legend.text = element_text(size=20),
        )
dev.off()
```

<!-- Draw UMAP and Dotplot for marker genes by DIFseq -->
<!-- ```{r UMAP} -->
<!-- x_corrected <- read.table(paste0(dir_inference,"corrected_count.txt")) -->
<!-- colnames(x_corrected) <- metadata$Sample -->
<!-- rownames(x_corrected) <- gene_list -->
<!-- rownames(metadata) <- metadata$Sample -->

<!-- Corrected_DIFseq <- CreateSeuratObject(counts = log1p(x_corrected), meta.data = metadata, project = paste0(proj,"_corrected"))  -->
<!-- # Corrected_DIFseq <- NormalizeData(Corrected_DIFseq) -->

<!-- # scaling -->
<!-- Corrected_DIFseq <- ScaleData(Corrected_DIFseq, features = gene_list) -->

<!-- # Run PCA -->
<!-- Corrected_DIFseq <- RunPCA(Corrected_DIFseq, features = gene_list) -->

<!-- ElbowPlot(Corrected_DIFseq, ndims = 30) -->

<!-- Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, reduction = "pca",  -->
<!--                                dims = 1:20, min.dist = 0.5, n.neighbours = 100) -->
<!-- # UMAP_Seurat <- Corrected_DIFseq[["umap"]]@cell.embeddings -->

<!-- DIFseq_celltype <- factor(label_switch[w_est]) -->
<!-- levels(DIFseq_celltype) <-  c("Alpha", "Beta", "Delta&Gamma", "Acinar", "Ductal", "Other") -->
<!-- Corrected_DIFseq$DIFseq_cluster <- DIFseq_celltype -->

<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "DIFseq_cluster",label = TRUE) -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "CellType", label = TRUE) -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "Study") -->
<!-- DimPlot(Corrected_DIFseq, reduction = "umap", group.by = "Disease") -->
<!-- ``` -->


<!-- Draw feature plots for known marker genes -->
<!-- ```{r feature_plot} -->
<!-- marker_genes <- c("GCG", "INS", "PPY", "SST", "PRSS1", "KRT19") -->
<!-- FeaturePlot(Corrected_DIFseq, features = marker_genes, min.cutoff = "q9") -->
<!-- ``` -->

<!-- ```{r} -->

<!-- DotPlot(Corrected_DIFseq, features = marker_genes, cols = c("blue", "red"), dot.scale = 8, group.by = "DIFseq_cluster") + RotatedAxis() -->
<!-- ``` -->
### Auxiliary function
```{r UMAP_plot, eval = FALSE}
plot_UMAP<-function(umap_var,col,p_name,leg_name, shuffle = TRUE){

  if(shuffle){
    shuffle_label <- sample(1:nrow(umap_var), nrow(umap_var))
    umap_var <- umap_var[shuffle_label,]
    col <- col[shuffle_label]
  }

  # The image with legend
  jpeg(paste(p_name,"_with_legend.jpeg",sep=""),width = 1440, height = 1080)
  par(mar=c(5.1,6.1,4.1,2.1))
  plot(umap_var,t="n",xaxt="n",yaxt="n",xlab="",ylab="")#main="tsne_uncorrected_by_batch")
  axis(1,cex.axis=6,line=2.5,tick = F)#plot the x axis
  axis(2,cex.axis=6,tick = F)#plot the y axis
  points(umap_var,pch=19 ,col= col,cex=3)
  legend("bottomright",legend=leg_name[,1],pch=19,col=leg_name[,2],cex=2)
  dev.off()

  # The image without legend
  jpeg(paste(p_name,".jpeg",sep=""),width = 1440, height = 1080)
  par(mar=c(5.1,6.1,4.1,2.1))
  plot(umap_var,t="n",xaxt="n",yaxt="n",xlab="",ylab="")#main="tsne_uncorrected_by_batch")
  axis(1,cex.axis=6,line=2.5,tick = F)#plot the x axis
  axis(2,cex.axis=6,tick = F)#plot the y axis
  points(umap_var,pch=19 ,col= col,cex=3)
  dev.off()

}
```

### Setting color palettes for batch, cell type and treatment
```{r coloring, eval = FALSE}
color_by_batch<-viridis(B)
color_by_celltype<-rainbow(length(celltype_name))
color_by_treatment<-cm.colors(Num_Treatment)

# Point color
study_name <- unique(metadata$Study)
treat_name <- unique(metadata$Disease)

b_ind <- factor(metadata$Study, levels = study_name)
t_ind <- factor(metadata$Disease, levels = treat_name)
celltype_ind <- metadata$CellType

cell_color_by_batch <- color_by_batch[b_ind]
cell_color_by_celltype <- color_by_celltype[celltype_ind]
cell_color_by_treatment <- color_by_treatment[t_ind]

# Legend
legend_batch <- cbind(study_name,color_by_batch)
legend_celltype <- cbind(levels(celltype_ind),color_by_celltype)
legend_treatment <- cbind(treat_name,color_by_treatment)
```


### UMAP for raw count data
```{r UMAP_raw, eval = FALSE}
Raw_simulation <- CreateSeuratObject(counts = y_obs, meta.data = metadata, project = paste0(proj,"_raw"))

Raw_simulation <- ScaleData(Raw_simulation, features = gene_list)
Raw_simulation <- RunPCA(Raw_simulation, features = gene_list)

ElbowPlot(Raw_simulation, ndims= 50)

```

```{r plot_raw, eval = FALSE}
set.seed(1234)
Raw_simulation <- RunUMAP(Raw_simulation, dims = 1:20, min.dist = 0.5, n.neighbours = 100)

# Coordinate
UMAP_unc <- Raw_simulation[["umap"]]@cell.embeddings

# color by batch
method <- "Unc"
unc_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch")
plot_UMAP(UMAP_unc,cell_color_by_batch,unc_by_batch,legend_batch)

# color by cell type
unc_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype")
plot_UMAP(UMAP_unc,cell_color_by_celltype,unc_by_celltype,legend_celltype)

# color by treatment
unc_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment")
plot_UMAP(UMAP_unc,cell_color_by_treatment,unc_by_treatment,legend_treatment)
```

### UMAP for the corrected count data by DIFseq
```{r PCA_correct, eval = FALSE}
Corrected_DIFseq <- CreateSeuratObject(counts = x_corrected, meta.data = metadata, project = "DIFseq_corrected")
# scaling
Corrected_DIFseq <- ScaleData(Corrected_DIFseq, features = gene_list)
# Run PCA
Corrected_DIFseq <- RunPCA(Corrected_DIFseq, features = gene_list)
ElbowPlot(Corrected_DIFseq, ndims= 50)
```

```{r UMAP, eval = FALSE}

# Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, dims = 1:30)
Corrected_DIFseq <- RunUMAP(Corrected_DIFseq, dims = 1:20, min.dist = 0.5, n.neighbours = 100)
UMAP_DIFseq <- Corrected_DIFseq[["umap"]]@cell.embeddings

method <- "DIFseq"
# color by batch
DIFseq_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch")
plot_UMAP(UMAP_DIFseq,cell_color_by_batch,DIFseq_by_batch,legend_batch)

# color by cell type
DIFseq_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype")
plot_UMAP(UMAP_DIFseq,cell_color_by_celltype,DIFseq_by_celltype,legend_celltype)

# color by treatment
DIFseq_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment")
plot_UMAP(UMAP_DIFseq,cell_color_by_treatment,DIFseq_by_treatment,legend_treatment)
```

### UMAP for the corrected data by Seurat and MiloR
```{r UMAP_comparison, eval = FALSE}
# Seurat
load(paste0("04UMAP_coord_Seurat_",proj,"_v",ver,".RData"))

method <- "Seurat"
# color by batch
Seurat_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch")
plot_UMAP(UMAP_Seurat,cell_color_by_batch,Seurat_by_batch,legend_batch)

# color by cell type
Seurat_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype")
plot_UMAP(UMAP_Seurat,cell_color_by_celltype,Seurat_by_celltype,legend_celltype)

# color by treatment
Seurat_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment")
plot_UMAP(UMAP_Seurat,cell_color_by_treatment,Seurat_by_treatment,legend_treatment)

# Seurat
load(paste0("04UMAP_coord_MiloR_",proj,"_v",ver,".RData"))

method <- "MiloR"
# color by batch
MiloR_by_batch <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_batch")
plot_UMAP(UMAP_MiloR,cell_color_by_batch,MiloR_by_batch,legend_batch)

# color by cell type
MiloR_by_celltype <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_celltype")
plot_UMAP(UMAP_MiloR,cell_color_by_celltype,MiloR_by_celltype,legend_celltype)

# color by treatment
MiloR_by_treatment <- paste0("Images/UMAP_",method,"_",proj,"_v",ver,"_K",K_opt,"_by_treatment")
plot_UMAP(UMAP_MiloR,cell_color_by_treatment,MiloR_by_treatment,legend_treatment)
```

```{r save}
Today <- Sys.Date()
save.image(paste0(paste0(Today,"Results_DIFseq_",proj,"_v",ver,".RData")))
```
